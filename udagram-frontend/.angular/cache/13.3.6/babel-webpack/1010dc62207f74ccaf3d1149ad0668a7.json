{"ast":null,"code":"import _createForOfIteratorHelper from \"F:\\\\New folder (17)\\\\nd0067-c4-deployment-process-project-starter\\\\udagram\\\\udagram-frontend\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createForOfIteratorHelper.js\";\nimport _get from \"F:\\\\New folder (17)\\\\nd0067-c4-deployment-process-project-starter\\\\udagram\\\\udagram-frontend\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\get.js\";\nimport _getPrototypeOf from \"F:\\\\New folder (17)\\\\nd0067-c4-deployment-process-project-starter\\\\udagram\\\\udagram-frontend\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\getPrototypeOf.js\";\nimport _inherits from \"F:\\\\New folder (17)\\\\nd0067-c4-deployment-process-project-starter\\\\udagram\\\\udagram-frontend\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\inherits.js\";\nimport _createSuper from \"F:\\\\New folder (17)\\\\nd0067-c4-deployment-process-project-starter\\\\udagram\\\\udagram-frontend\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createSuper.js\";\nimport _toConsumableArray from \"F:\\\\New folder (17)\\\\nd0067-c4-deployment-process-project-starter\\\\udagram\\\\udagram-frontend\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\toConsumableArray.js\";\nimport _classCallCheck from \"F:\\\\New folder (17)\\\\nd0067-c4-deployment-process-project-starter\\\\udagram\\\\udagram-frontend\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\classCallCheck.js\";\nimport _createClass from \"F:\\\\New folder (17)\\\\nd0067-c4-deployment-process-project-starter\\\\udagram\\\\udagram-frontend\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createClass.js\";\n\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, \"throw\" === context.method) { if (delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel; context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, \"constructor\", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n\nimport * as i0 from '@angular/core';\nimport { Directive, HostListener, Component, ChangeDetectionStrategy, Injectable, Injector, InjectionToken, Inject, Optional, EventEmitter, Attribute, SkipSelf, Output, ViewChild, ContentChild, Input, TemplateRef, APP_INITIALIZER, NgZone, NgModule } from '@angular/core';\nimport { NgControl, NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { __decorate, __awaiter } from 'tslib';\nimport { fromEvent, Subject, BehaviorSubject } from 'rxjs';\nimport * as i3 from '@angular/router';\nimport { NavigationStart, PRIMARY_OUTLET, ActivatedRoute, ChildrenOutletContexts } from '@angular/router';\nimport { LIFECYCLE_WILL_ENTER, LIFECYCLE_DID_ENTER, LIFECYCLE_WILL_LEAVE, LIFECYCLE_DID_LEAVE, LIFECYCLE_WILL_UNLOAD, isPlatform, getPlatforms, componentOnReady, actionSheetController, alertController, loadingController, menuController, pickerController, modalController, popoverController, toastController, createAnimation, getTimeGivenProgression, createGesture, setupConfig } from '@ionic/core';\nexport { IonicSafeString, IonicSlides, IonicSwiper, createAnimation, createGesture, getPlatforms, getTimeGivenProgression, iosTransitionAnimation, isPlatform, mdTransitionAnimation } from '@ionic/core';\nimport { filter, switchMap, distinctUntilChanged } from 'rxjs/operators';\nimport * as i1 from '@angular/common';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport { applyPolyfills, defineCustomElements } from '@ionic/core/loader';\nvar _c0 = [\"*\"];\nvar _c1 = [\"outlet\"];\nvar _c2 = [[[\"\", \"slot\", \"top\"]], \"*\"];\nvar _c3 = [\"[slot=top]\", \"*\"];\n\nfunction IonModal_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 1);\n    i0.ɵɵelementContainer(1, 2);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r0.template);\n  }\n}\n\nfunction IonPopover_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0, 1);\n  }\n\n  if (rf & 2) {\n    var ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r0.template);\n  }\n}\n\nvar raf = function raf(h) {\n  if (typeof __zone_symbol__requestAnimationFrame === 'function') {\n    return __zone_symbol__requestAnimationFrame(h);\n  }\n\n  if (typeof requestAnimationFrame === 'function') {\n    return requestAnimationFrame(h);\n  }\n\n  return setTimeout(h);\n};\n\nvar ValueAccessor = /*#__PURE__*/(function () {\n  var ValueAccessor = /*#__PURE__*/function () {\n    function ValueAccessor(injector, el) {\n      _classCallCheck(this, ValueAccessor);\n\n      this.injector = injector;\n      this.el = el;\n\n      this.onChange = function () {\n        /**/\n      };\n\n      this.onTouched = function () {\n        /**/\n      };\n    }\n\n    _createClass(ValueAccessor, [{\n      key: \"writeValue\",\n      value: function writeValue(value) {\n        /**\n         * TODO for Ionic 6:\n         * Change `value == null ? '' : value;`\n         * to `value`. This was a fix for IE9, but IE9\n         * is no longer supported; however, this change\n         * is potentially a breaking change\n         */\n        this.el.nativeElement.value = this.lastValue = value == null ? '' : value;\n        setIonicClasses(this.el);\n      }\n    }, {\n      key: \"handleChangeEvent\",\n      value: function handleChangeEvent(el, value) {\n        if (el === this.el.nativeElement) {\n          if (value !== this.lastValue) {\n            this.lastValue = value;\n            this.onChange(value);\n          }\n\n          setIonicClasses(this.el);\n        }\n      }\n    }, {\n      key: \"_handleBlurEvent\",\n      value: function _handleBlurEvent(el) {\n        if (el === this.el.nativeElement) {\n          this.onTouched();\n          setIonicClasses(this.el);\n        }\n      }\n    }, {\n      key: \"registerOnChange\",\n      value: function registerOnChange(fn) {\n        this.onChange = fn;\n      }\n    }, {\n      key: \"registerOnTouched\",\n      value: function registerOnTouched(fn) {\n        this.onTouched = fn;\n      }\n    }, {\n      key: \"setDisabledState\",\n      value: function setDisabledState(isDisabled) {\n        this.el.nativeElement.disabled = isDisabled;\n      }\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        if (this.statusChanges) {\n          this.statusChanges.unsubscribe();\n        }\n      }\n    }, {\n      key: \"ngAfterViewInit\",\n      value: function ngAfterViewInit() {\n        var _this = this;\n\n        var ngControl;\n\n        try {\n          ngControl = this.injector.get(NgControl);\n        } catch (_a) {\n          /* No FormControl or ngModel binding */\n        }\n\n        if (!ngControl) {\n          return;\n        } // Listen for changes in validity, disabled, or pending states\n\n\n        if (ngControl.statusChanges) {\n          this.statusChanges = ngControl.statusChanges.subscribe(function () {\n            return setIonicClasses(_this.el);\n          });\n        }\n        /**\n         * TODO Remove this in favor of https://github.com/angular/angular/issues/10887\n         * whenever it is implemented. Currently, Ionic's form status classes\n         * do not react to changes when developers manually call\n         * Angular form control methods such as markAsTouched.\n         * This results in Ionic's form status classes being out\n         * of sync with the ng form status classes.\n         * This patches the methods to manually sync\n         * the classes until this feature is implemented in Angular.\n         */\n\n\n        var formControl = ngControl.control;\n\n        if (formControl) {\n          var methodsToPatch = ['markAsTouched', 'markAllAsTouched', 'markAsUntouched', 'markAsDirty', 'markAsPristine'];\n          methodsToPatch.forEach(function (method) {\n            if (typeof formControl[method] !== 'undefined') {\n              var oldFn = formControl[method].bind(formControl);\n\n              formControl[method] = function () {\n                oldFn.apply(void 0, arguments);\n                setIonicClasses(_this.el);\n              };\n            }\n          });\n        }\n      }\n    }]);\n\n    return ValueAccessor;\n  }();\n\n  /** @nocollapse */\n  ValueAccessor.ɵfac = function ValueAccessor_Factory(t) {\n    return new (t || ValueAccessor)(i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n  /** @nocollapse */\n\n\n  ValueAccessor.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ValueAccessor,\n    hostBindings: function ValueAccessor_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"ionBlur\", function ValueAccessor_ionBlur_HostBindingHandler($event) {\n          return ctx._handleBlurEvent($event.target);\n        });\n      }\n    }\n  });\n  return ValueAccessor;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar setIonicClasses = function setIonicClasses(element) {\n  raf(function () {\n    var input = element.nativeElement;\n    var hasValue = input.value != null && input.value.toString().length > 0;\n    var classes = getClasses(input);\n    setClasses(input, classes);\n    var item = input.closest('ion-item');\n\n    if (item) {\n      if (hasValue) {\n        setClasses(item, [].concat(_toConsumableArray(classes), ['item-has-value']));\n      } else {\n        setClasses(item, classes);\n      }\n    }\n  });\n};\n\nvar getClasses = function getClasses(element) {\n  var classList = element.classList;\n  var classes = [];\n\n  for (var i = 0; i < classList.length; i++) {\n    var item = classList.item(i);\n\n    if (item !== null && startsWith(item, 'ng-')) {\n      classes.push(\"ion-\".concat(item.substring(3)));\n    }\n  }\n\n  return classes;\n};\n\nvar setClasses = function setClasses(element, classes) {\n  var classList = element.classList;\n  classList.remove('ion-valid', 'ion-invalid', 'ion-touched', 'ion-untouched', 'ion-dirty', 'ion-pristine');\n  classList.add.apply(classList, _toConsumableArray(classes));\n};\n\nvar startsWith = function startsWith(input, search) {\n  return input.substring(0, search.length) === search;\n};\n\nvar BooleanValueAccessorDirective = /*#__PURE__*/(function () {\n  var BooleanValueAccessorDirective = /*#__PURE__*/function (_ValueAccessor) {\n    _inherits(BooleanValueAccessorDirective, _ValueAccessor);\n\n    var _super = _createSuper(BooleanValueAccessorDirective);\n\n    function BooleanValueAccessorDirective(injector, el) {\n      _classCallCheck(this, BooleanValueAccessorDirective);\n\n      return _super.call(this, injector, el);\n    }\n\n    _createClass(BooleanValueAccessorDirective, [{\n      key: \"writeValue\",\n      value: function writeValue(value) {\n        this.el.nativeElement.checked = this.lastValue = value == null ? false : value;\n        setIonicClasses(this.el);\n      }\n    }, {\n      key: \"_handleIonChange\",\n      value: function _handleIonChange(el) {\n        this.handleChangeEvent(el, el.checked);\n      }\n    }]);\n\n    return BooleanValueAccessorDirective;\n  }(ValueAccessor);\n\n  /** @nocollapse */\n  BooleanValueAccessorDirective.ɵfac = function BooleanValueAccessorDirective_Factory(t) {\n    return new (t || BooleanValueAccessorDirective)(i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n  /** @nocollapse */\n\n\n  BooleanValueAccessorDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: BooleanValueAccessorDirective,\n    selectors: [[\"ion-checkbox\"], [\"ion-toggle\"]],\n    hostBindings: function BooleanValueAccessorDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"ionChange\", function BooleanValueAccessorDirective_ionChange_HostBindingHandler($event) {\n          return ctx._handleIonChange($event.target);\n        });\n      }\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: BooleanValueAccessorDirective,\n      multi: true\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return BooleanValueAccessorDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar NumericValueAccessorDirective = /*#__PURE__*/(function () {\n  var NumericValueAccessorDirective = /*#__PURE__*/function (_ValueAccessor2) {\n    _inherits(NumericValueAccessorDirective, _ValueAccessor2);\n\n    var _super2 = _createSuper(NumericValueAccessorDirective);\n\n    function NumericValueAccessorDirective(injector, el) {\n      _classCallCheck(this, NumericValueAccessorDirective);\n\n      return _super2.call(this, injector, el);\n    }\n\n    _createClass(NumericValueAccessorDirective, [{\n      key: \"_handleIonChange\",\n      value: function _handleIonChange(el) {\n        this.handleChangeEvent(el, el.value);\n      }\n    }, {\n      key: \"registerOnChange\",\n      value: function registerOnChange(fn) {\n        _get(_getPrototypeOf(NumericValueAccessorDirective.prototype), \"registerOnChange\", this).call(this, function (value) {\n          fn(value === '' ? null : parseFloat(value));\n        });\n      }\n    }]);\n\n    return NumericValueAccessorDirective;\n  }(ValueAccessor);\n\n  /** @nocollapse */\n  NumericValueAccessorDirective.ɵfac = function NumericValueAccessorDirective_Factory(t) {\n    return new (t || NumericValueAccessorDirective)(i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n  /** @nocollapse */\n\n\n  NumericValueAccessorDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NumericValueAccessorDirective,\n    selectors: [[\"ion-input\", \"type\", \"number\"]],\n    hostBindings: function NumericValueAccessorDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"ionChange\", function NumericValueAccessorDirective_ionChange_HostBindingHandler($event) {\n          return ctx._handleIonChange($event.target);\n        });\n      }\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: NumericValueAccessorDirective,\n      multi: true\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return NumericValueAccessorDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar RadioValueAccessorDirective = /*#__PURE__*/(function () {\n  var RadioValueAccessorDirective = /*#__PURE__*/function (_ValueAccessor3) {\n    _inherits(RadioValueAccessorDirective, _ValueAccessor3);\n\n    var _super3 = _createSuper(RadioValueAccessorDirective);\n\n    function RadioValueAccessorDirective(injector, el) {\n      _classCallCheck(this, RadioValueAccessorDirective);\n\n      return _super3.call(this, injector, el);\n    }\n\n    _createClass(RadioValueAccessorDirective, [{\n      key: \"_handleIonSelect\",\n      value: function _handleIonSelect(el) {\n        this.handleChangeEvent(el, el.checked);\n      }\n    }]);\n\n    return RadioValueAccessorDirective;\n  }(ValueAccessor);\n\n  /** @nocollapse */\n  RadioValueAccessorDirective.ɵfac = function RadioValueAccessorDirective_Factory(t) {\n    return new (t || RadioValueAccessorDirective)(i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n  /** @nocollapse */\n\n\n  RadioValueAccessorDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: RadioValueAccessorDirective,\n    selectors: [[\"ion-radio\"]],\n    hostBindings: function RadioValueAccessorDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"ionSelect\", function RadioValueAccessorDirective_ionSelect_HostBindingHandler($event) {\n          return ctx._handleIonSelect($event.target);\n        });\n      }\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: RadioValueAccessorDirective,\n      multi: true\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return RadioValueAccessorDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar SelectValueAccessorDirective = /*#__PURE__*/(function () {\n  var SelectValueAccessorDirective = /*#__PURE__*/function (_ValueAccessor4) {\n    _inherits(SelectValueAccessorDirective, _ValueAccessor4);\n\n    var _super4 = _createSuper(SelectValueAccessorDirective);\n\n    function SelectValueAccessorDirective(injector, el) {\n      _classCallCheck(this, SelectValueAccessorDirective);\n\n      return _super4.call(this, injector, el);\n    }\n\n    _createClass(SelectValueAccessorDirective, [{\n      key: \"_handleChangeEvent\",\n      value: function _handleChangeEvent(el) {\n        this.handleChangeEvent(el, el.value);\n      }\n    }]);\n\n    return SelectValueAccessorDirective;\n  }(ValueAccessor);\n\n  /** @nocollapse */\n  SelectValueAccessorDirective.ɵfac = function SelectValueAccessorDirective_Factory(t) {\n    return new (t || SelectValueAccessorDirective)(i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n  /** @nocollapse */\n\n\n  SelectValueAccessorDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: SelectValueAccessorDirective,\n    selectors: [[\"ion-range\"], [\"ion-select\"], [\"ion-radio-group\"], [\"ion-segment\"], [\"ion-datetime\"]],\n    hostBindings: function SelectValueAccessorDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"ionChange\", function SelectValueAccessorDirective_ionChange_HostBindingHandler($event) {\n          return ctx._handleChangeEvent($event.target);\n        });\n      }\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: SelectValueAccessorDirective,\n      multi: true\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return SelectValueAccessorDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar TextValueAccessorDirective = /*#__PURE__*/(function () {\n  var TextValueAccessorDirective = /*#__PURE__*/function (_ValueAccessor5) {\n    _inherits(TextValueAccessorDirective, _ValueAccessor5);\n\n    var _super5 = _createSuper(TextValueAccessorDirective);\n\n    function TextValueAccessorDirective(injector, el) {\n      _classCallCheck(this, TextValueAccessorDirective);\n\n      return _super5.call(this, injector, el);\n    }\n\n    _createClass(TextValueAccessorDirective, [{\n      key: \"_handleInputEvent\",\n      value: function _handleInputEvent(el) {\n        this.handleChangeEvent(el, el.value);\n      }\n    }]);\n\n    return TextValueAccessorDirective;\n  }(ValueAccessor);\n\n  /** @nocollapse */\n  TextValueAccessorDirective.ɵfac = function TextValueAccessorDirective_Factory(t) {\n    return new (t || TextValueAccessorDirective)(i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n  /** @nocollapse */\n\n\n  TextValueAccessorDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TextValueAccessorDirective,\n    selectors: [[\"ion-input\", 3, \"type\", \"number\"], [\"ion-textarea\"], [\"ion-searchbar\"]],\n    hostBindings: function TextValueAccessorDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"ionChange\", function TextValueAccessorDirective_ionChange_HostBindingHandler($event) {\n          return ctx._handleInputEvent($event.target);\n        });\n      }\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: TextValueAccessorDirective,\n      multi: true\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return TextValueAccessorDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/* eslint-disable */\n\n\nvar proxyInputs = function proxyInputs(Cmp, inputs) {\n  var Prototype = Cmp.prototype;\n  inputs.forEach(function (item) {\n    Object.defineProperty(Prototype, item, {\n      get: function get() {\n        return this.el[item];\n      },\n      set: function set(val) {\n        var _this2 = this;\n\n        this.z.runOutsideAngular(function () {\n          return _this2.el[item] = val;\n        });\n      }\n    });\n  });\n};\n\nvar proxyMethods = function proxyMethods(Cmp, methods) {\n  var Prototype = Cmp.prototype;\n  methods.forEach(function (methodName) {\n    Prototype[methodName] = function () {\n      var _this3 = this;\n\n      var args = arguments;\n      return this.z.runOutsideAngular(function () {\n        return _this3.el[methodName].apply(_this3.el, args);\n      });\n    };\n  });\n};\n\nvar proxyOutputs = function proxyOutputs(instance, el, events) {\n  events.forEach(function (eventName) {\n    return instance[eventName] = fromEvent(el, eventName);\n  });\n};\n\nvar defineCustomElement = function defineCustomElement(tagName, customElement) {\n  if (customElement !== undefined && typeof customElements !== 'undefined' && !customElements.get(tagName)) {\n    customElements.define(tagName, customElement);\n  }\n}; // tslint:disable-next-line: only-arrow-functions\n\n\nfunction ProxyCmp(opts) {\n  var decorator = function decorator(cls) {\n    var defineCustomElementFn = opts.defineCustomElementFn,\n        inputs = opts.inputs,\n        methods = opts.methods;\n\n    if (defineCustomElementFn !== undefined) {\n      defineCustomElementFn();\n    }\n\n    if (inputs) {\n      proxyInputs(cls, inputs);\n    }\n\n    if (methods) {\n      proxyMethods(cls, methods);\n    }\n\n    return cls;\n  };\n\n  return decorator;\n}\n\nvar IonAccordion = /*#__PURE__*/(function () {\n  var IonAccordion = /*#__PURE__*/_createClass(function IonAccordion(c, r, z) {\n    _classCallCheck(this, IonAccordion);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  });\n\n  /** @nocollapse */\n  IonAccordion.ɵfac = function IonAccordion_Factory(t) {\n    return new (t || IonAccordion)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonAccordion.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonAccordion,\n    selectors: [[\"ion-accordion\"]],\n    inputs: {\n      disabled: \"disabled\",\n      mode: \"mode\",\n      readonly: \"readonly\",\n      toggleIcon: \"toggleIcon\",\n      toggleIconSlot: \"toggleIconSlot\",\n      value: \"value\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonAccordion_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonAccordion = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['disabled', 'mode', 'readonly', 'toggleIcon', 'toggleIconSlot', 'value']\n  })], IonAccordion);\n  return IonAccordion;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonAccordionGroup = /*#__PURE__*/(function () {\n  var IonAccordionGroup = /*#__PURE__*/_createClass(function IonAccordionGroup(c, r, z) {\n    _classCallCheck(this, IonAccordionGroup);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, ['ionChange']);\n  });\n\n  /** @nocollapse */\n  IonAccordionGroup.ɵfac = function IonAccordionGroup_Factory(t) {\n    return new (t || IonAccordionGroup)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonAccordionGroup.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonAccordionGroup,\n    selectors: [[\"ion-accordion-group\"]],\n    inputs: {\n      animated: \"animated\",\n      disabled: \"disabled\",\n      expand: \"expand\",\n      mode: \"mode\",\n      multiple: \"multiple\",\n      readonly: \"readonly\",\n      value: \"value\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonAccordionGroup_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonAccordionGroup = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['animated', 'disabled', 'expand', 'mode', 'multiple', 'readonly', 'value']\n  })], IonAccordionGroup);\n  return IonAccordionGroup;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonApp = /*#__PURE__*/(function () {\n  var IonApp = /*#__PURE__*/_createClass(function IonApp(c, r, z) {\n    _classCallCheck(this, IonApp);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  });\n\n  /** @nocollapse */\n  IonApp.ɵfac = function IonApp_Factory(t) {\n    return new (t || IonApp)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonApp.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonApp,\n    selectors: [[\"ion-app\"]],\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonApp_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonApp = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined\n  })], IonApp);\n  return IonApp;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonAvatar = /*#__PURE__*/(function () {\n  var IonAvatar = /*#__PURE__*/_createClass(function IonAvatar(c, r, z) {\n    _classCallCheck(this, IonAvatar);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  });\n\n  /** @nocollapse */\n  IonAvatar.ɵfac = function IonAvatar_Factory(t) {\n    return new (t || IonAvatar)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonAvatar.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonAvatar,\n    selectors: [[\"ion-avatar\"]],\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonAvatar_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonAvatar = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined\n  })], IonAvatar);\n  return IonAvatar;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonBackButton = /*#__PURE__*/(function () {\n  var IonBackButton = /*#__PURE__*/_createClass(function IonBackButton(c, r, z) {\n    _classCallCheck(this, IonBackButton);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  });\n\n  /** @nocollapse */\n  IonBackButton.ɵfac = function IonBackButton_Factory(t) {\n    return new (t || IonBackButton)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonBackButton.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonBackButton,\n    selectors: [[\"ion-back-button\"]],\n    inputs: {\n      color: \"color\",\n      defaultHref: \"defaultHref\",\n      disabled: \"disabled\",\n      icon: \"icon\",\n      mode: \"mode\",\n      routerAnimation: \"routerAnimation\",\n      text: \"text\",\n      type: \"type\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonBackButton_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonBackButton = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['color', 'defaultHref', 'disabled', 'icon', 'mode', 'routerAnimation', 'text', 'type']\n  })], IonBackButton);\n  return IonBackButton;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonBackdrop = /*#__PURE__*/(function () {\n  var IonBackdrop = /*#__PURE__*/_createClass(function IonBackdrop(c, r, z) {\n    _classCallCheck(this, IonBackdrop);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, ['ionBackdropTap']);\n  });\n\n  /** @nocollapse */\n  IonBackdrop.ɵfac = function IonBackdrop_Factory(t) {\n    return new (t || IonBackdrop)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonBackdrop.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonBackdrop,\n    selectors: [[\"ion-backdrop\"]],\n    inputs: {\n      stopPropagation: \"stopPropagation\",\n      tappable: \"tappable\",\n      visible: \"visible\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonBackdrop_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonBackdrop = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['stopPropagation', 'tappable', 'visible']\n  })], IonBackdrop);\n  return IonBackdrop;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonBadge = /*#__PURE__*/(function () {\n  var IonBadge = /*#__PURE__*/_createClass(function IonBadge(c, r, z) {\n    _classCallCheck(this, IonBadge);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  });\n\n  /** @nocollapse */\n  IonBadge.ɵfac = function IonBadge_Factory(t) {\n    return new (t || IonBadge)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonBadge.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonBadge,\n    selectors: [[\"ion-badge\"]],\n    inputs: {\n      color: \"color\",\n      mode: \"mode\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonBadge_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonBadge = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['color', 'mode']\n  })], IonBadge);\n  return IonBadge;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonBreadcrumb = /*#__PURE__*/(function () {\n  var IonBreadcrumb = /*#__PURE__*/_createClass(function IonBreadcrumb(c, r, z) {\n    _classCallCheck(this, IonBreadcrumb);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, ['ionFocus', 'ionBlur']);\n  });\n\n  /** @nocollapse */\n  IonBreadcrumb.ɵfac = function IonBreadcrumb_Factory(t) {\n    return new (t || IonBreadcrumb)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonBreadcrumb.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonBreadcrumb,\n    selectors: [[\"ion-breadcrumb\"]],\n    inputs: {\n      active: \"active\",\n      color: \"color\",\n      disabled: \"disabled\",\n      download: \"download\",\n      href: \"href\",\n      mode: \"mode\",\n      rel: \"rel\",\n      routerAnimation: \"routerAnimation\",\n      routerDirection: \"routerDirection\",\n      separator: \"separator\",\n      target: \"target\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonBreadcrumb_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonBreadcrumb = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['active', 'color', 'disabled', 'download', 'href', 'mode', 'rel', 'routerAnimation', 'routerDirection', 'separator', 'target']\n  })], IonBreadcrumb);\n  return IonBreadcrumb;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonBreadcrumbs = /*#__PURE__*/(function () {\n  var IonBreadcrumbs = /*#__PURE__*/_createClass(function IonBreadcrumbs(c, r, z) {\n    _classCallCheck(this, IonBreadcrumbs);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, ['ionCollapsedClick']);\n  });\n\n  /** @nocollapse */\n  IonBreadcrumbs.ɵfac = function IonBreadcrumbs_Factory(t) {\n    return new (t || IonBreadcrumbs)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonBreadcrumbs.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonBreadcrumbs,\n    selectors: [[\"ion-breadcrumbs\"]],\n    inputs: {\n      color: \"color\",\n      itemsAfterCollapse: \"itemsAfterCollapse\",\n      itemsBeforeCollapse: \"itemsBeforeCollapse\",\n      maxItems: \"maxItems\",\n      mode: \"mode\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonBreadcrumbs_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonBreadcrumbs = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['color', 'itemsAfterCollapse', 'itemsBeforeCollapse', 'maxItems', 'mode']\n  })], IonBreadcrumbs);\n  return IonBreadcrumbs;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonButton = /*#__PURE__*/(function () {\n  var IonButton = /*#__PURE__*/_createClass(function IonButton(c, r, z) {\n    _classCallCheck(this, IonButton);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, ['ionFocus', 'ionBlur']);\n  });\n\n  /** @nocollapse */\n  IonButton.ɵfac = function IonButton_Factory(t) {\n    return new (t || IonButton)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonButton.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonButton,\n    selectors: [[\"ion-button\"]],\n    inputs: {\n      buttonType: \"buttonType\",\n      color: \"color\",\n      disabled: \"disabled\",\n      download: \"download\",\n      expand: \"expand\",\n      fill: \"fill\",\n      href: \"href\",\n      mode: \"mode\",\n      rel: \"rel\",\n      routerAnimation: \"routerAnimation\",\n      routerDirection: \"routerDirection\",\n      shape: \"shape\",\n      size: \"size\",\n      strong: \"strong\",\n      target: \"target\",\n      type: \"type\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonButton_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonButton = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['buttonType', 'color', 'disabled', 'download', 'expand', 'fill', 'href', 'mode', 'rel', 'routerAnimation', 'routerDirection', 'shape', 'size', 'strong', 'target', 'type']\n  })], IonButton);\n  return IonButton;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonButtons = /*#__PURE__*/(function () {\n  var IonButtons = /*#__PURE__*/_createClass(function IonButtons(c, r, z) {\n    _classCallCheck(this, IonButtons);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  });\n\n  /** @nocollapse */\n  IonButtons.ɵfac = function IonButtons_Factory(t) {\n    return new (t || IonButtons)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonButtons.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonButtons,\n    selectors: [[\"ion-buttons\"]],\n    inputs: {\n      collapse: \"collapse\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonButtons_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonButtons = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['collapse']\n  })], IonButtons);\n  return IonButtons;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonCard = /*#__PURE__*/(function () {\n  var IonCard = /*#__PURE__*/_createClass(function IonCard(c, r, z) {\n    _classCallCheck(this, IonCard);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  });\n\n  /** @nocollapse */\n  IonCard.ɵfac = function IonCard_Factory(t) {\n    return new (t || IonCard)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonCard.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonCard,\n    selectors: [[\"ion-card\"]],\n    inputs: {\n      button: \"button\",\n      color: \"color\",\n      disabled: \"disabled\",\n      download: \"download\",\n      href: \"href\",\n      mode: \"mode\",\n      rel: \"rel\",\n      routerAnimation: \"routerAnimation\",\n      routerDirection: \"routerDirection\",\n      target: \"target\",\n      type: \"type\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonCard_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonCard = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['button', 'color', 'disabled', 'download', 'href', 'mode', 'rel', 'routerAnimation', 'routerDirection', 'target', 'type']\n  })], IonCard);\n  return IonCard;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonCardContent = /*#__PURE__*/(function () {\n  var IonCardContent = /*#__PURE__*/_createClass(function IonCardContent(c, r, z) {\n    _classCallCheck(this, IonCardContent);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  });\n\n  /** @nocollapse */\n  IonCardContent.ɵfac = function IonCardContent_Factory(t) {\n    return new (t || IonCardContent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonCardContent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonCardContent,\n    selectors: [[\"ion-card-content\"]],\n    inputs: {\n      mode: \"mode\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonCardContent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonCardContent = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['mode']\n  })], IonCardContent);\n  return IonCardContent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonCardHeader = /*#__PURE__*/(function () {\n  var IonCardHeader = /*#__PURE__*/_createClass(function IonCardHeader(c, r, z) {\n    _classCallCheck(this, IonCardHeader);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  });\n\n  /** @nocollapse */\n  IonCardHeader.ɵfac = function IonCardHeader_Factory(t) {\n    return new (t || IonCardHeader)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonCardHeader.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonCardHeader,\n    selectors: [[\"ion-card-header\"]],\n    inputs: {\n      color: \"color\",\n      mode: \"mode\",\n      translucent: \"translucent\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonCardHeader_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonCardHeader = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['color', 'mode', 'translucent']\n  })], IonCardHeader);\n  return IonCardHeader;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonCardSubtitle = /*#__PURE__*/(function () {\n  var IonCardSubtitle = /*#__PURE__*/_createClass(function IonCardSubtitle(c, r, z) {\n    _classCallCheck(this, IonCardSubtitle);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  });\n\n  /** @nocollapse */\n  IonCardSubtitle.ɵfac = function IonCardSubtitle_Factory(t) {\n    return new (t || IonCardSubtitle)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonCardSubtitle.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonCardSubtitle,\n    selectors: [[\"ion-card-subtitle\"]],\n    inputs: {\n      color: \"color\",\n      mode: \"mode\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonCardSubtitle_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonCardSubtitle = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['color', 'mode']\n  })], IonCardSubtitle);\n  return IonCardSubtitle;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonCardTitle = /*#__PURE__*/(function () {\n  var IonCardTitle = /*#__PURE__*/_createClass(function IonCardTitle(c, r, z) {\n    _classCallCheck(this, IonCardTitle);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  });\n\n  /** @nocollapse */\n  IonCardTitle.ɵfac = function IonCardTitle_Factory(t) {\n    return new (t || IonCardTitle)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonCardTitle.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonCardTitle,\n    selectors: [[\"ion-card-title\"]],\n    inputs: {\n      color: \"color\",\n      mode: \"mode\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonCardTitle_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonCardTitle = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['color', 'mode']\n  })], IonCardTitle);\n  return IonCardTitle;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonCheckbox = /*#__PURE__*/(function () {\n  var IonCheckbox = /*#__PURE__*/_createClass(function IonCheckbox(c, r, z) {\n    _classCallCheck(this, IonCheckbox);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, ['ionChange', 'ionFocus', 'ionBlur']);\n  });\n\n  /** @nocollapse */\n  IonCheckbox.ɵfac = function IonCheckbox_Factory(t) {\n    return new (t || IonCheckbox)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonCheckbox.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonCheckbox,\n    selectors: [[\"ion-checkbox\"]],\n    inputs: {\n      checked: \"checked\",\n      color: \"color\",\n      disabled: \"disabled\",\n      indeterminate: \"indeterminate\",\n      mode: \"mode\",\n      name: \"name\",\n      value: \"value\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonCheckbox_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonCheckbox = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['checked', 'color', 'disabled', 'indeterminate', 'mode', 'name', 'value']\n  })], IonCheckbox);\n  return IonCheckbox;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonChip = /*#__PURE__*/(function () {\n  var IonChip = /*#__PURE__*/_createClass(function IonChip(c, r, z) {\n    _classCallCheck(this, IonChip);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  });\n\n  /** @nocollapse */\n  IonChip.ɵfac = function IonChip_Factory(t) {\n    return new (t || IonChip)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonChip.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonChip,\n    selectors: [[\"ion-chip\"]],\n    inputs: {\n      color: \"color\",\n      disabled: \"disabled\",\n      mode: \"mode\",\n      outline: \"outline\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonChip_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonChip = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['color', 'disabled', 'mode', 'outline']\n  })], IonChip);\n  return IonChip;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonCol = /*#__PURE__*/(function () {\n  var IonCol = /*#__PURE__*/_createClass(function IonCol(c, r, z) {\n    _classCallCheck(this, IonCol);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  });\n\n  /** @nocollapse */\n  IonCol.ɵfac = function IonCol_Factory(t) {\n    return new (t || IonCol)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonCol.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonCol,\n    selectors: [[\"ion-col\"]],\n    inputs: {\n      offset: \"offset\",\n      offsetLg: \"offsetLg\",\n      offsetMd: \"offsetMd\",\n      offsetSm: \"offsetSm\",\n      offsetXl: \"offsetXl\",\n      offsetXs: \"offsetXs\",\n      pull: \"pull\",\n      pullLg: \"pullLg\",\n      pullMd: \"pullMd\",\n      pullSm: \"pullSm\",\n      pullXl: \"pullXl\",\n      pullXs: \"pullXs\",\n      push: \"push\",\n      pushLg: \"pushLg\",\n      pushMd: \"pushMd\",\n      pushSm: \"pushSm\",\n      pushXl: \"pushXl\",\n      pushXs: \"pushXs\",\n      size: \"size\",\n      sizeLg: \"sizeLg\",\n      sizeMd: \"sizeMd\",\n      sizeSm: \"sizeSm\",\n      sizeXl: \"sizeXl\",\n      sizeXs: \"sizeXs\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonCol_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonCol = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['offset', 'offsetLg', 'offsetMd', 'offsetSm', 'offsetXl', 'offsetXs', 'pull', 'pullLg', 'pullMd', 'pullSm', 'pullXl', 'pullXs', 'push', 'pushLg', 'pushMd', 'pushSm', 'pushXl', 'pushXs', 'size', 'sizeLg', 'sizeMd', 'sizeSm', 'sizeXl', 'sizeXs']\n  })], IonCol);\n  return IonCol;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonContent = /*#__PURE__*/(function () {\n  var IonContent = /*#__PURE__*/_createClass(function IonContent(c, r, z) {\n    _classCallCheck(this, IonContent);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, ['ionScrollStart', 'ionScroll', 'ionScrollEnd']);\n  });\n\n  /** @nocollapse */\n  IonContent.ɵfac = function IonContent_Factory(t) {\n    return new (t || IonContent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonContent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonContent,\n    selectors: [[\"ion-content\"]],\n    inputs: {\n      color: \"color\",\n      forceOverscroll: \"forceOverscroll\",\n      fullscreen: \"fullscreen\",\n      scrollEvents: \"scrollEvents\",\n      scrollX: \"scrollX\",\n      scrollY: \"scrollY\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonContent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonContent = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['color', 'forceOverscroll', 'fullscreen', 'scrollEvents', 'scrollX', 'scrollY'],\n    methods: ['getScrollElement', 'scrollToTop', 'scrollToBottom', 'scrollByPoint', 'scrollToPoint']\n  })], IonContent);\n  return IonContent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonDatetime = /*#__PURE__*/(function () {\n  var IonDatetime = /*#__PURE__*/_createClass(function IonDatetime(c, r, z) {\n    _classCallCheck(this, IonDatetime);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, ['ionCancel', 'ionChange', 'ionFocus', 'ionBlur']);\n  });\n\n  /** @nocollapse */\n  IonDatetime.ɵfac = function IonDatetime_Factory(t) {\n    return new (t || IonDatetime)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonDatetime.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonDatetime,\n    selectors: [[\"ion-datetime\"]],\n    inputs: {\n      cancelText: \"cancelText\",\n      clearText: \"clearText\",\n      color: \"color\",\n      dayValues: \"dayValues\",\n      disabled: \"disabled\",\n      doneText: \"doneText\",\n      firstDayOfWeek: \"firstDayOfWeek\",\n      hourCycle: \"hourCycle\",\n      hourValues: \"hourValues\",\n      isDateEnabled: \"isDateEnabled\",\n      locale: \"locale\",\n      max: \"max\",\n      min: \"min\",\n      minuteValues: \"minuteValues\",\n      mode: \"mode\",\n      monthValues: \"monthValues\",\n      name: \"name\",\n      presentation: \"presentation\",\n      readonly: \"readonly\",\n      showClearButton: \"showClearButton\",\n      showDefaultButtons: \"showDefaultButtons\",\n      showDefaultTimeLabel: \"showDefaultTimeLabel\",\n      showDefaultTitle: \"showDefaultTitle\",\n      size: \"size\",\n      value: \"value\",\n      yearValues: \"yearValues\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonDatetime_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonDatetime = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['cancelText', 'clearText', 'color', 'dayValues', 'disabled', 'doneText', 'firstDayOfWeek', 'hourCycle', 'hourValues', 'isDateEnabled', 'locale', 'max', 'min', 'minuteValues', 'mode', 'monthValues', 'name', 'presentation', 'readonly', 'showClearButton', 'showDefaultButtons', 'showDefaultTimeLabel', 'showDefaultTitle', 'size', 'value', 'yearValues'],\n    methods: ['confirm', 'reset', 'cancel']\n  })], IonDatetime);\n  return IonDatetime;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonFab = /*#__PURE__*/(function () {\n  var IonFab = /*#__PURE__*/_createClass(function IonFab(c, r, z) {\n    _classCallCheck(this, IonFab);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  });\n\n  /** @nocollapse */\n  IonFab.ɵfac = function IonFab_Factory(t) {\n    return new (t || IonFab)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonFab.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonFab,\n    selectors: [[\"ion-fab\"]],\n    inputs: {\n      activated: \"activated\",\n      edge: \"edge\",\n      horizontal: \"horizontal\",\n      vertical: \"vertical\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonFab_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonFab = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['activated', 'edge', 'horizontal', 'vertical'],\n    methods: ['close']\n  })], IonFab);\n  return IonFab;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonFabButton = /*#__PURE__*/(function () {\n  var IonFabButton = /*#__PURE__*/_createClass(function IonFabButton(c, r, z) {\n    _classCallCheck(this, IonFabButton);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, ['ionFocus', 'ionBlur']);\n  });\n\n  /** @nocollapse */\n  IonFabButton.ɵfac = function IonFabButton_Factory(t) {\n    return new (t || IonFabButton)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonFabButton.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonFabButton,\n    selectors: [[\"ion-fab-button\"]],\n    inputs: {\n      activated: \"activated\",\n      closeIcon: \"closeIcon\",\n      color: \"color\",\n      disabled: \"disabled\",\n      download: \"download\",\n      href: \"href\",\n      mode: \"mode\",\n      rel: \"rel\",\n      routerAnimation: \"routerAnimation\",\n      routerDirection: \"routerDirection\",\n      show: \"show\",\n      size: \"size\",\n      target: \"target\",\n      translucent: \"translucent\",\n      type: \"type\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonFabButton_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonFabButton = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['activated', 'closeIcon', 'color', 'disabled', 'download', 'href', 'mode', 'rel', 'routerAnimation', 'routerDirection', 'show', 'size', 'target', 'translucent', 'type']\n  })], IonFabButton);\n  return IonFabButton;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonFabList = /*#__PURE__*/(function () {\n  var IonFabList = /*#__PURE__*/_createClass(function IonFabList(c, r, z) {\n    _classCallCheck(this, IonFabList);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  });\n\n  /** @nocollapse */\n  IonFabList.ɵfac = function IonFabList_Factory(t) {\n    return new (t || IonFabList)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonFabList.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonFabList,\n    selectors: [[\"ion-fab-list\"]],\n    inputs: {\n      activated: \"activated\",\n      side: \"side\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonFabList_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonFabList = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['activated', 'side']\n  })], IonFabList);\n  return IonFabList;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonFooter = /*#__PURE__*/(function () {\n  var IonFooter = /*#__PURE__*/_createClass(function IonFooter(c, r, z) {\n    _classCallCheck(this, IonFooter);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  });\n\n  /** @nocollapse */\n  IonFooter.ɵfac = function IonFooter_Factory(t) {\n    return new (t || IonFooter)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonFooter.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonFooter,\n    selectors: [[\"ion-footer\"]],\n    inputs: {\n      collapse: \"collapse\",\n      mode: \"mode\",\n      translucent: \"translucent\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonFooter_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonFooter = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['collapse', 'mode', 'translucent']\n  })], IonFooter);\n  return IonFooter;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonGrid = /*#__PURE__*/(function () {\n  var IonGrid = /*#__PURE__*/_createClass(function IonGrid(c, r, z) {\n    _classCallCheck(this, IonGrid);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  });\n\n  /** @nocollapse */\n  IonGrid.ɵfac = function IonGrid_Factory(t) {\n    return new (t || IonGrid)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonGrid.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonGrid,\n    selectors: [[\"ion-grid\"]],\n    inputs: {\n      fixed: \"fixed\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonGrid_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonGrid = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['fixed']\n  })], IonGrid);\n  return IonGrid;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonHeader = /*#__PURE__*/(function () {\n  var IonHeader = /*#__PURE__*/_createClass(function IonHeader(c, r, z) {\n    _classCallCheck(this, IonHeader);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  });\n\n  /** @nocollapse */\n  IonHeader.ɵfac = function IonHeader_Factory(t) {\n    return new (t || IonHeader)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonHeader.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonHeader,\n    selectors: [[\"ion-header\"]],\n    inputs: {\n      collapse: \"collapse\",\n      mode: \"mode\",\n      translucent: \"translucent\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonHeader_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonHeader = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['collapse', 'mode', 'translucent']\n  })], IonHeader);\n  return IonHeader;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonIcon = /*#__PURE__*/(function () {\n  var IonIcon = /*#__PURE__*/_createClass(function IonIcon(c, r, z) {\n    _classCallCheck(this, IonIcon);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  });\n\n  /** @nocollapse */\n  IonIcon.ɵfac = function IonIcon_Factory(t) {\n    return new (t || IonIcon)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonIcon.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonIcon,\n    selectors: [[\"ion-icon\"]],\n    inputs: {\n      color: \"color\",\n      flipRtl: \"flipRtl\",\n      icon: \"icon\",\n      ios: \"ios\",\n      lazy: \"lazy\",\n      md: \"md\",\n      mode: \"mode\",\n      name: \"name\",\n      sanitize: \"sanitize\",\n      size: \"size\",\n      src: \"src\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonIcon_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonIcon = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['color', 'flipRtl', 'icon', 'ios', 'lazy', 'md', 'mode', 'name', 'sanitize', 'size', 'src']\n  })], IonIcon);\n  return IonIcon;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonImg = /*#__PURE__*/(function () {\n  var IonImg = /*#__PURE__*/_createClass(function IonImg(c, r, z) {\n    _classCallCheck(this, IonImg);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, ['ionImgWillLoad', 'ionImgDidLoad', 'ionError']);\n  });\n\n  /** @nocollapse */\n  IonImg.ɵfac = function IonImg_Factory(t) {\n    return new (t || IonImg)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonImg.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonImg,\n    selectors: [[\"ion-img\"]],\n    inputs: {\n      alt: \"alt\",\n      src: \"src\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonImg_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonImg = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['alt', 'src']\n  })], IonImg);\n  return IonImg;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonInfiniteScroll = /*#__PURE__*/(function () {\n  var IonInfiniteScroll = /*#__PURE__*/_createClass(function IonInfiniteScroll(c, r, z) {\n    _classCallCheck(this, IonInfiniteScroll);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, ['ionInfinite']);\n  });\n\n  /** @nocollapse */\n  IonInfiniteScroll.ɵfac = function IonInfiniteScroll_Factory(t) {\n    return new (t || IonInfiniteScroll)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonInfiniteScroll.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonInfiniteScroll,\n    selectors: [[\"ion-infinite-scroll\"]],\n    inputs: {\n      disabled: \"disabled\",\n      position: \"position\",\n      threshold: \"threshold\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonInfiniteScroll_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonInfiniteScroll = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['disabled', 'position', 'threshold'],\n    methods: ['complete']\n  })], IonInfiniteScroll);\n  return IonInfiniteScroll;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonInfiniteScrollContent = /*#__PURE__*/(function () {\n  var IonInfiniteScrollContent = /*#__PURE__*/_createClass(function IonInfiniteScrollContent(c, r, z) {\n    _classCallCheck(this, IonInfiniteScrollContent);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  });\n\n  /** @nocollapse */\n  IonInfiniteScrollContent.ɵfac = function IonInfiniteScrollContent_Factory(t) {\n    return new (t || IonInfiniteScrollContent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonInfiniteScrollContent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonInfiniteScrollContent,\n    selectors: [[\"ion-infinite-scroll-content\"]],\n    inputs: {\n      loadingSpinner: \"loadingSpinner\",\n      loadingText: \"loadingText\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonInfiniteScrollContent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonInfiniteScrollContent = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['loadingSpinner', 'loadingText']\n  })], IonInfiniteScrollContent);\n  return IonInfiniteScrollContent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonInput = /*#__PURE__*/(function () {\n  var IonInput = /*#__PURE__*/_createClass(function IonInput(c, r, z) {\n    _classCallCheck(this, IonInput);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, ['ionInput', 'ionChange', 'ionBlur', 'ionFocus']);\n  });\n\n  /** @nocollapse */\n  IonInput.ɵfac = function IonInput_Factory(t) {\n    return new (t || IonInput)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonInput.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonInput,\n    selectors: [[\"ion-input\"]],\n    inputs: {\n      accept: \"accept\",\n      autocapitalize: \"autocapitalize\",\n      autocomplete: \"autocomplete\",\n      autocorrect: \"autocorrect\",\n      autofocus: \"autofocus\",\n      clearInput: \"clearInput\",\n      clearOnEdit: \"clearOnEdit\",\n      color: \"color\",\n      debounce: \"debounce\",\n      disabled: \"disabled\",\n      enterkeyhint: \"enterkeyhint\",\n      inputmode: \"inputmode\",\n      max: \"max\",\n      maxlength: \"maxlength\",\n      min: \"min\",\n      minlength: \"minlength\",\n      mode: \"mode\",\n      multiple: \"multiple\",\n      name: \"name\",\n      pattern: \"pattern\",\n      placeholder: \"placeholder\",\n      readonly: \"readonly\",\n      required: \"required\",\n      size: \"size\",\n      spellcheck: \"spellcheck\",\n      step: \"step\",\n      type: \"type\",\n      value: \"value\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonInput_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonInput = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['accept', 'autocapitalize', 'autocomplete', 'autocorrect', 'autofocus', 'clearInput', 'clearOnEdit', 'color', 'debounce', 'disabled', 'enterkeyhint', 'inputmode', 'max', 'maxlength', 'min', 'minlength', 'mode', 'multiple', 'name', 'pattern', 'placeholder', 'readonly', 'required', 'size', 'spellcheck', 'step', 'type', 'value'],\n    methods: ['setFocus', 'getInputElement']\n  })], IonInput);\n  return IonInput;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonItem = /*#__PURE__*/(function () {\n  var IonItem = /*#__PURE__*/_createClass(function IonItem(c, r, z) {\n    _classCallCheck(this, IonItem);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  });\n\n  /** @nocollapse */\n  IonItem.ɵfac = function IonItem_Factory(t) {\n    return new (t || IonItem)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonItem.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonItem,\n    selectors: [[\"ion-item\"]],\n    inputs: {\n      button: \"button\",\n      color: \"color\",\n      counter: \"counter\",\n      counterFormatter: \"counterFormatter\",\n      detail: \"detail\",\n      detailIcon: \"detailIcon\",\n      disabled: \"disabled\",\n      download: \"download\",\n      fill: \"fill\",\n      href: \"href\",\n      lines: \"lines\",\n      mode: \"mode\",\n      rel: \"rel\",\n      routerAnimation: \"routerAnimation\",\n      routerDirection: \"routerDirection\",\n      shape: \"shape\",\n      target: \"target\",\n      type: \"type\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonItem_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonItem = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['button', 'color', 'counter', 'counterFormatter', 'detail', 'detailIcon', 'disabled', 'download', 'fill', 'href', 'lines', 'mode', 'rel', 'routerAnimation', 'routerDirection', 'shape', 'target', 'type']\n  })], IonItem);\n  return IonItem;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonItemDivider = /*#__PURE__*/(function () {\n  var IonItemDivider = /*#__PURE__*/_createClass(function IonItemDivider(c, r, z) {\n    _classCallCheck(this, IonItemDivider);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  });\n\n  /** @nocollapse */\n  IonItemDivider.ɵfac = function IonItemDivider_Factory(t) {\n    return new (t || IonItemDivider)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonItemDivider.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonItemDivider,\n    selectors: [[\"ion-item-divider\"]],\n    inputs: {\n      color: \"color\",\n      mode: \"mode\",\n      sticky: \"sticky\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonItemDivider_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonItemDivider = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['color', 'mode', 'sticky']\n  })], IonItemDivider);\n  return IonItemDivider;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonItemGroup = /*#__PURE__*/(function () {\n  var IonItemGroup = /*#__PURE__*/_createClass(function IonItemGroup(c, r, z) {\n    _classCallCheck(this, IonItemGroup);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  });\n\n  /** @nocollapse */\n  IonItemGroup.ɵfac = function IonItemGroup_Factory(t) {\n    return new (t || IonItemGroup)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonItemGroup.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonItemGroup,\n    selectors: [[\"ion-item-group\"]],\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonItemGroup_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonItemGroup = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined\n  })], IonItemGroup);\n  return IonItemGroup;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonItemOption = /*#__PURE__*/(function () {\n  var IonItemOption = /*#__PURE__*/_createClass(function IonItemOption(c, r, z) {\n    _classCallCheck(this, IonItemOption);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  });\n\n  /** @nocollapse */\n  IonItemOption.ɵfac = function IonItemOption_Factory(t) {\n    return new (t || IonItemOption)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonItemOption.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonItemOption,\n    selectors: [[\"ion-item-option\"]],\n    inputs: {\n      color: \"color\",\n      disabled: \"disabled\",\n      download: \"download\",\n      expandable: \"expandable\",\n      href: \"href\",\n      mode: \"mode\",\n      rel: \"rel\",\n      target: \"target\",\n      type: \"type\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonItemOption_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonItemOption = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['color', 'disabled', 'download', 'expandable', 'href', 'mode', 'rel', 'target', 'type']\n  })], IonItemOption);\n  return IonItemOption;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonItemOptions = /*#__PURE__*/(function () {\n  var IonItemOptions = /*#__PURE__*/_createClass(function IonItemOptions(c, r, z) {\n    _classCallCheck(this, IonItemOptions);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, ['ionSwipe']);\n  });\n\n  /** @nocollapse */\n  IonItemOptions.ɵfac = function IonItemOptions_Factory(t) {\n    return new (t || IonItemOptions)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonItemOptions.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonItemOptions,\n    selectors: [[\"ion-item-options\"]],\n    inputs: {\n      side: \"side\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonItemOptions_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonItemOptions = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['side']\n  })], IonItemOptions);\n  return IonItemOptions;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonItemSliding = /*#__PURE__*/(function () {\n  var IonItemSliding = /*#__PURE__*/_createClass(function IonItemSliding(c, r, z) {\n    _classCallCheck(this, IonItemSliding);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, ['ionDrag']);\n  });\n\n  /** @nocollapse */\n  IonItemSliding.ɵfac = function IonItemSliding_Factory(t) {\n    return new (t || IonItemSliding)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonItemSliding.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonItemSliding,\n    selectors: [[\"ion-item-sliding\"]],\n    inputs: {\n      disabled: \"disabled\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonItemSliding_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonItemSliding = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['disabled'],\n    methods: ['getOpenAmount', 'getSlidingRatio', 'open', 'close', 'closeOpened']\n  })], IonItemSliding);\n  return IonItemSliding;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonLabel = /*#__PURE__*/(function () {\n  var IonLabel = /*#__PURE__*/_createClass(function IonLabel(c, r, z) {\n    _classCallCheck(this, IonLabel);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  });\n\n  /** @nocollapse */\n  IonLabel.ɵfac = function IonLabel_Factory(t) {\n    return new (t || IonLabel)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonLabel.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonLabel,\n    selectors: [[\"ion-label\"]],\n    inputs: {\n      color: \"color\",\n      mode: \"mode\",\n      position: \"position\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonLabel_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonLabel = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['color', 'mode', 'position']\n  })], IonLabel);\n  return IonLabel;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonList = /*#__PURE__*/(function () {\n  var IonList = /*#__PURE__*/_createClass(function IonList(c, r, z) {\n    _classCallCheck(this, IonList);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  });\n\n  /** @nocollapse */\n  IonList.ɵfac = function IonList_Factory(t) {\n    return new (t || IonList)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonList.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonList,\n    selectors: [[\"ion-list\"]],\n    inputs: {\n      inset: \"inset\",\n      lines: \"lines\",\n      mode: \"mode\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonList_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonList = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['inset', 'lines', 'mode'],\n    methods: ['closeSlidingItems']\n  })], IonList);\n  return IonList;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonListHeader = /*#__PURE__*/(function () {\n  var IonListHeader = /*#__PURE__*/_createClass(function IonListHeader(c, r, z) {\n    _classCallCheck(this, IonListHeader);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  });\n\n  /** @nocollapse */\n  IonListHeader.ɵfac = function IonListHeader_Factory(t) {\n    return new (t || IonListHeader)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonListHeader.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonListHeader,\n    selectors: [[\"ion-list-header\"]],\n    inputs: {\n      color: \"color\",\n      lines: \"lines\",\n      mode: \"mode\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonListHeader_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonListHeader = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['color', 'lines', 'mode']\n  })], IonListHeader);\n  return IonListHeader;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonMenu = /*#__PURE__*/(function () {\n  var IonMenu = /*#__PURE__*/_createClass(function IonMenu(c, r, z) {\n    _classCallCheck(this, IonMenu);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, ['ionWillOpen', 'ionWillClose', 'ionDidOpen', 'ionDidClose']);\n  });\n\n  /** @nocollapse */\n  IonMenu.ɵfac = function IonMenu_Factory(t) {\n    return new (t || IonMenu)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonMenu.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonMenu,\n    selectors: [[\"ion-menu\"]],\n    inputs: {\n      contentId: \"contentId\",\n      disabled: \"disabled\",\n      maxEdgeStart: \"maxEdgeStart\",\n      menuId: \"menuId\",\n      side: \"side\",\n      swipeGesture: \"swipeGesture\",\n      type: \"type\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonMenu_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonMenu = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['contentId', 'disabled', 'maxEdgeStart', 'menuId', 'side', 'swipeGesture', 'type'],\n    methods: ['isOpen', 'isActive', 'open', 'close', 'toggle', 'setOpen']\n  })], IonMenu);\n  return IonMenu;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonMenuButton = /*#__PURE__*/(function () {\n  var IonMenuButton = /*#__PURE__*/_createClass(function IonMenuButton(c, r, z) {\n    _classCallCheck(this, IonMenuButton);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  });\n\n  /** @nocollapse */\n  IonMenuButton.ɵfac = function IonMenuButton_Factory(t) {\n    return new (t || IonMenuButton)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonMenuButton.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonMenuButton,\n    selectors: [[\"ion-menu-button\"]],\n    inputs: {\n      autoHide: \"autoHide\",\n      color: \"color\",\n      disabled: \"disabled\",\n      menu: \"menu\",\n      mode: \"mode\",\n      type: \"type\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonMenuButton_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonMenuButton = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['autoHide', 'color', 'disabled', 'menu', 'mode', 'type']\n  })], IonMenuButton);\n  return IonMenuButton;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonMenuToggle = /*#__PURE__*/(function () {\n  var IonMenuToggle = /*#__PURE__*/_createClass(function IonMenuToggle(c, r, z) {\n    _classCallCheck(this, IonMenuToggle);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  });\n\n  /** @nocollapse */\n  IonMenuToggle.ɵfac = function IonMenuToggle_Factory(t) {\n    return new (t || IonMenuToggle)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonMenuToggle.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonMenuToggle,\n    selectors: [[\"ion-menu-toggle\"]],\n    inputs: {\n      autoHide: \"autoHide\",\n      menu: \"menu\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonMenuToggle_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonMenuToggle = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['autoHide', 'menu']\n  })], IonMenuToggle);\n  return IonMenuToggle;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonNav = /*#__PURE__*/(function () {\n  var IonNav = /*#__PURE__*/_createClass(function IonNav(c, r, z) {\n    _classCallCheck(this, IonNav);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, ['ionNavWillChange', 'ionNavDidChange']);\n  });\n\n  /** @nocollapse */\n  IonNav.ɵfac = function IonNav_Factory(t) {\n    return new (t || IonNav)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonNav.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonNav,\n    selectors: [[\"ion-nav\"]],\n    inputs: {\n      animated: \"animated\",\n      animation: \"animation\",\n      root: \"root\",\n      rootParams: \"rootParams\",\n      swipeGesture: \"swipeGesture\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonNav_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonNav = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['animated', 'animation', 'root', 'rootParams', 'swipeGesture'],\n    methods: ['push', 'insert', 'insertPages', 'pop', 'popTo', 'popToRoot', 'removeIndex', 'setRoot', 'setPages', 'getActive', 'getByIndex', 'canGoBack', 'getPrevious']\n  })], IonNav);\n  return IonNav;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonNavLink = /*#__PURE__*/(function () {\n  var IonNavLink = /*#__PURE__*/_createClass(function IonNavLink(c, r, z) {\n    _classCallCheck(this, IonNavLink);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  });\n\n  /** @nocollapse */\n  IonNavLink.ɵfac = function IonNavLink_Factory(t) {\n    return new (t || IonNavLink)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonNavLink.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonNavLink,\n    selectors: [[\"ion-nav-link\"]],\n    inputs: {\n      component: \"component\",\n      componentProps: \"componentProps\",\n      routerAnimation: \"routerAnimation\",\n      routerDirection: \"routerDirection\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonNavLink_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonNavLink = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['component', 'componentProps', 'routerAnimation', 'routerDirection']\n  })], IonNavLink);\n  return IonNavLink;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonNote = /*#__PURE__*/(function () {\n  var IonNote = /*#__PURE__*/_createClass(function IonNote(c, r, z) {\n    _classCallCheck(this, IonNote);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  });\n\n  /** @nocollapse */\n  IonNote.ɵfac = function IonNote_Factory(t) {\n    return new (t || IonNote)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonNote.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonNote,\n    selectors: [[\"ion-note\"]],\n    inputs: {\n      color: \"color\",\n      mode: \"mode\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonNote_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonNote = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['color', 'mode']\n  })], IonNote);\n  return IonNote;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonProgressBar = /*#__PURE__*/(function () {\n  var IonProgressBar = /*#__PURE__*/_createClass(function IonProgressBar(c, r, z) {\n    _classCallCheck(this, IonProgressBar);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  });\n\n  /** @nocollapse */\n  IonProgressBar.ɵfac = function IonProgressBar_Factory(t) {\n    return new (t || IonProgressBar)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonProgressBar.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonProgressBar,\n    selectors: [[\"ion-progress-bar\"]],\n    inputs: {\n      buffer: \"buffer\",\n      color: \"color\",\n      mode: \"mode\",\n      reversed: \"reversed\",\n      type: \"type\",\n      value: \"value\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonProgressBar_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonProgressBar = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['buffer', 'color', 'mode', 'reversed', 'type', 'value']\n  })], IonProgressBar);\n  return IonProgressBar;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonRadio = /*#__PURE__*/(function () {\n  var IonRadio = /*#__PURE__*/_createClass(function IonRadio(c, r, z) {\n    _classCallCheck(this, IonRadio);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, ['ionFocus', 'ionBlur']);\n  });\n\n  /** @nocollapse */\n  IonRadio.ɵfac = function IonRadio_Factory(t) {\n    return new (t || IonRadio)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonRadio.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonRadio,\n    selectors: [[\"ion-radio\"]],\n    inputs: {\n      color: \"color\",\n      disabled: \"disabled\",\n      mode: \"mode\",\n      name: \"name\",\n      value: \"value\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonRadio_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonRadio = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['color', 'disabled', 'mode', 'name', 'value']\n  })], IonRadio);\n  return IonRadio;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonRadioGroup = /*#__PURE__*/(function () {\n  var IonRadioGroup = /*#__PURE__*/_createClass(function IonRadioGroup(c, r, z) {\n    _classCallCheck(this, IonRadioGroup);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, ['ionChange']);\n  });\n\n  /** @nocollapse */\n  IonRadioGroup.ɵfac = function IonRadioGroup_Factory(t) {\n    return new (t || IonRadioGroup)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonRadioGroup.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonRadioGroup,\n    selectors: [[\"ion-radio-group\"]],\n    inputs: {\n      allowEmptySelection: \"allowEmptySelection\",\n      name: \"name\",\n      value: \"value\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonRadioGroup_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonRadioGroup = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['allowEmptySelection', 'name', 'value']\n  })], IonRadioGroup);\n  return IonRadioGroup;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonRange = /*#__PURE__*/(function () {\n  var IonRange = /*#__PURE__*/_createClass(function IonRange(c, r, z) {\n    _classCallCheck(this, IonRange);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, ['ionChange', 'ionFocus', 'ionBlur', 'ionKnobMoveStart', 'ionKnobMoveEnd']);\n  });\n\n  /** @nocollapse */\n  IonRange.ɵfac = function IonRange_Factory(t) {\n    return new (t || IonRange)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonRange.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonRange,\n    selectors: [[\"ion-range\"]],\n    inputs: {\n      color: \"color\",\n      debounce: \"debounce\",\n      disabled: \"disabled\",\n      dualKnobs: \"dualKnobs\",\n      max: \"max\",\n      min: \"min\",\n      mode: \"mode\",\n      name: \"name\",\n      pin: \"pin\",\n      pinFormatter: \"pinFormatter\",\n      snaps: \"snaps\",\n      step: \"step\",\n      ticks: \"ticks\",\n      value: \"value\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonRange_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonRange = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['color', 'debounce', 'disabled', 'dualKnobs', 'max', 'min', 'mode', 'name', 'pin', 'pinFormatter', 'snaps', 'step', 'ticks', 'value']\n  })], IonRange);\n  return IonRange;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonRefresher = /*#__PURE__*/(function () {\n  var IonRefresher = /*#__PURE__*/_createClass(function IonRefresher(c, r, z) {\n    _classCallCheck(this, IonRefresher);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, ['ionRefresh', 'ionPull', 'ionStart']);\n  });\n\n  /** @nocollapse */\n  IonRefresher.ɵfac = function IonRefresher_Factory(t) {\n    return new (t || IonRefresher)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonRefresher.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonRefresher,\n    selectors: [[\"ion-refresher\"]],\n    inputs: {\n      closeDuration: \"closeDuration\",\n      disabled: \"disabled\",\n      pullFactor: \"pullFactor\",\n      pullMax: \"pullMax\",\n      pullMin: \"pullMin\",\n      snapbackDuration: \"snapbackDuration\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonRefresher_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonRefresher = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['closeDuration', 'disabled', 'pullFactor', 'pullMax', 'pullMin', 'snapbackDuration'],\n    methods: ['complete', 'cancel', 'getProgress']\n  })], IonRefresher);\n  return IonRefresher;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonRefresherContent = /*#__PURE__*/(function () {\n  var IonRefresherContent = /*#__PURE__*/_createClass(function IonRefresherContent(c, r, z) {\n    _classCallCheck(this, IonRefresherContent);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  });\n\n  /** @nocollapse */\n  IonRefresherContent.ɵfac = function IonRefresherContent_Factory(t) {\n    return new (t || IonRefresherContent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonRefresherContent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonRefresherContent,\n    selectors: [[\"ion-refresher-content\"]],\n    inputs: {\n      pullingIcon: \"pullingIcon\",\n      pullingText: \"pullingText\",\n      refreshingSpinner: \"refreshingSpinner\",\n      refreshingText: \"refreshingText\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonRefresherContent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonRefresherContent = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['pullingIcon', 'pullingText', 'refreshingSpinner', 'refreshingText']\n  })], IonRefresherContent);\n  return IonRefresherContent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonReorder = /*#__PURE__*/(function () {\n  var IonReorder = /*#__PURE__*/_createClass(function IonReorder(c, r, z) {\n    _classCallCheck(this, IonReorder);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  });\n\n  /** @nocollapse */\n  IonReorder.ɵfac = function IonReorder_Factory(t) {\n    return new (t || IonReorder)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonReorder.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonReorder,\n    selectors: [[\"ion-reorder\"]],\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonReorder_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonReorder = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined\n  })], IonReorder);\n  return IonReorder;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonReorderGroup = /*#__PURE__*/(function () {\n  var IonReorderGroup = /*#__PURE__*/_createClass(function IonReorderGroup(c, r, z) {\n    _classCallCheck(this, IonReorderGroup);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, ['ionItemReorder']);\n  });\n\n  /** @nocollapse */\n  IonReorderGroup.ɵfac = function IonReorderGroup_Factory(t) {\n    return new (t || IonReorderGroup)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonReorderGroup.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonReorderGroup,\n    selectors: [[\"ion-reorder-group\"]],\n    inputs: {\n      disabled: \"disabled\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonReorderGroup_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonReorderGroup = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['disabled'],\n    methods: ['complete']\n  })], IonReorderGroup);\n  return IonReorderGroup;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonRippleEffect = /*#__PURE__*/(function () {\n  var IonRippleEffect = /*#__PURE__*/_createClass(function IonRippleEffect(c, r, z) {\n    _classCallCheck(this, IonRippleEffect);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  });\n\n  /** @nocollapse */\n  IonRippleEffect.ɵfac = function IonRippleEffect_Factory(t) {\n    return new (t || IonRippleEffect)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonRippleEffect.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonRippleEffect,\n    selectors: [[\"ion-ripple-effect\"]],\n    inputs: {\n      type: \"type\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonRippleEffect_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonRippleEffect = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['type'],\n    methods: ['addRipple']\n  })], IonRippleEffect);\n  return IonRippleEffect;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonRow = /*#__PURE__*/(function () {\n  var IonRow = /*#__PURE__*/_createClass(function IonRow(c, r, z) {\n    _classCallCheck(this, IonRow);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  });\n\n  /** @nocollapse */\n  IonRow.ɵfac = function IonRow_Factory(t) {\n    return new (t || IonRow)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonRow.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonRow,\n    selectors: [[\"ion-row\"]],\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonRow_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonRow = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined\n  })], IonRow);\n  return IonRow;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonSearchbar = /*#__PURE__*/(function () {\n  var IonSearchbar = /*#__PURE__*/_createClass(function IonSearchbar(c, r, z) {\n    _classCallCheck(this, IonSearchbar);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, ['ionInput', 'ionChange', 'ionCancel', 'ionClear', 'ionBlur', 'ionFocus']);\n  });\n\n  /** @nocollapse */\n  IonSearchbar.ɵfac = function IonSearchbar_Factory(t) {\n    return new (t || IonSearchbar)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonSearchbar.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonSearchbar,\n    selectors: [[\"ion-searchbar\"]],\n    inputs: {\n      animated: \"animated\",\n      autocomplete: \"autocomplete\",\n      autocorrect: \"autocorrect\",\n      cancelButtonIcon: \"cancelButtonIcon\",\n      cancelButtonText: \"cancelButtonText\",\n      clearIcon: \"clearIcon\",\n      color: \"color\",\n      debounce: \"debounce\",\n      disabled: \"disabled\",\n      enterkeyhint: \"enterkeyhint\",\n      inputmode: \"inputmode\",\n      mode: \"mode\",\n      placeholder: \"placeholder\",\n      searchIcon: \"searchIcon\",\n      showCancelButton: \"showCancelButton\",\n      showClearButton: \"showClearButton\",\n      spellcheck: \"spellcheck\",\n      type: \"type\",\n      value: \"value\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonSearchbar_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonSearchbar = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['animated', 'autocomplete', 'autocorrect', 'cancelButtonIcon', 'cancelButtonText', 'clearIcon', 'color', 'debounce', 'disabled', 'enterkeyhint', 'inputmode', 'mode', 'placeholder', 'searchIcon', 'showCancelButton', 'showClearButton', 'spellcheck', 'type', 'value'],\n    methods: ['setFocus', 'getInputElement']\n  })], IonSearchbar);\n  return IonSearchbar;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonSegment = /*#__PURE__*/(function () {\n  var IonSegment = /*#__PURE__*/_createClass(function IonSegment(c, r, z) {\n    _classCallCheck(this, IonSegment);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, ['ionChange']);\n  });\n\n  /** @nocollapse */\n  IonSegment.ɵfac = function IonSegment_Factory(t) {\n    return new (t || IonSegment)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonSegment.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonSegment,\n    selectors: [[\"ion-segment\"]],\n    inputs: {\n      color: \"color\",\n      disabled: \"disabled\",\n      mode: \"mode\",\n      scrollable: \"scrollable\",\n      selectOnFocus: \"selectOnFocus\",\n      swipeGesture: \"swipeGesture\",\n      value: \"value\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonSegment_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonSegment = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['color', 'disabled', 'mode', 'scrollable', 'selectOnFocus', 'swipeGesture', 'value']\n  })], IonSegment);\n  return IonSegment;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonSegmentButton = /*#__PURE__*/(function () {\n  var IonSegmentButton = /*#__PURE__*/_createClass(function IonSegmentButton(c, r, z) {\n    _classCallCheck(this, IonSegmentButton);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  });\n\n  /** @nocollapse */\n  IonSegmentButton.ɵfac = function IonSegmentButton_Factory(t) {\n    return new (t || IonSegmentButton)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonSegmentButton.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonSegmentButton,\n    selectors: [[\"ion-segment-button\"]],\n    inputs: {\n      disabled: \"disabled\",\n      layout: \"layout\",\n      mode: \"mode\",\n      type: \"type\",\n      value: \"value\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonSegmentButton_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonSegmentButton = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['disabled', 'layout', 'mode', 'type', 'value']\n  })], IonSegmentButton);\n  return IonSegmentButton;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonSelect = /*#__PURE__*/(function () {\n  var IonSelect = /*#__PURE__*/_createClass(function IonSelect(c, r, z) {\n    _classCallCheck(this, IonSelect);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, ['ionChange', 'ionCancel', 'ionDismiss', 'ionFocus', 'ionBlur']);\n  });\n\n  /** @nocollapse */\n  IonSelect.ɵfac = function IonSelect_Factory(t) {\n    return new (t || IonSelect)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonSelect.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonSelect,\n    selectors: [[\"ion-select\"]],\n    inputs: {\n      cancelText: \"cancelText\",\n      compareWith: \"compareWith\",\n      disabled: \"disabled\",\n      interface: \"interface\",\n      interfaceOptions: \"interfaceOptions\",\n      mode: \"mode\",\n      multiple: \"multiple\",\n      name: \"name\",\n      okText: \"okText\",\n      placeholder: \"placeholder\",\n      selectedText: \"selectedText\",\n      value: \"value\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonSelect_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonSelect = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['cancelText', 'compareWith', 'disabled', 'interface', 'interfaceOptions', 'mode', 'multiple', 'name', 'okText', 'placeholder', 'selectedText', 'value'],\n    methods: ['open']\n  })], IonSelect);\n  return IonSelect;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonSelectOption = /*#__PURE__*/(function () {\n  var IonSelectOption = /*#__PURE__*/_createClass(function IonSelectOption(c, r, z) {\n    _classCallCheck(this, IonSelectOption);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  });\n\n  /** @nocollapse */\n  IonSelectOption.ɵfac = function IonSelectOption_Factory(t) {\n    return new (t || IonSelectOption)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonSelectOption.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonSelectOption,\n    selectors: [[\"ion-select-option\"]],\n    inputs: {\n      disabled: \"disabled\",\n      value: \"value\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonSelectOption_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonSelectOption = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['disabled', 'value']\n  })], IonSelectOption);\n  return IonSelectOption;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonSkeletonText = /*#__PURE__*/(function () {\n  var IonSkeletonText = /*#__PURE__*/_createClass(function IonSkeletonText(c, r, z) {\n    _classCallCheck(this, IonSkeletonText);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  });\n\n  /** @nocollapse */\n  IonSkeletonText.ɵfac = function IonSkeletonText_Factory(t) {\n    return new (t || IonSkeletonText)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonSkeletonText.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonSkeletonText,\n    selectors: [[\"ion-skeleton-text\"]],\n    inputs: {\n      animated: \"animated\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonSkeletonText_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonSkeletonText = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['animated']\n  })], IonSkeletonText);\n  return IonSkeletonText;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonSlide = /*#__PURE__*/(function () {\n  var IonSlide = /*#__PURE__*/_createClass(function IonSlide(c, r, z) {\n    _classCallCheck(this, IonSlide);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  });\n\n  /** @nocollapse */\n  IonSlide.ɵfac = function IonSlide_Factory(t) {\n    return new (t || IonSlide)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonSlide.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonSlide,\n    selectors: [[\"ion-slide\"]],\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonSlide_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonSlide = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined\n  })], IonSlide);\n  return IonSlide;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonSlides = /*#__PURE__*/(function () {\n  var IonSlides = /*#__PURE__*/_createClass(function IonSlides(c, r, z) {\n    _classCallCheck(this, IonSlides);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, ['ionSlidesDidLoad', 'ionSlideTap', 'ionSlideDoubleTap', 'ionSlideWillChange', 'ionSlideDidChange', 'ionSlideNextStart', 'ionSlidePrevStart', 'ionSlideNextEnd', 'ionSlidePrevEnd', 'ionSlideTransitionStart', 'ionSlideTransitionEnd', 'ionSlideDrag', 'ionSlideReachStart', 'ionSlideReachEnd', 'ionSlideTouchStart', 'ionSlideTouchEnd']);\n  });\n\n  /** @nocollapse */\n  IonSlides.ɵfac = function IonSlides_Factory(t) {\n    return new (t || IonSlides)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonSlides.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonSlides,\n    selectors: [[\"ion-slides\"]],\n    inputs: {\n      mode: \"mode\",\n      options: \"options\",\n      pager: \"pager\",\n      scrollbar: \"scrollbar\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonSlides_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonSlides = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['mode', 'options', 'pager', 'scrollbar'],\n    methods: ['update', 'updateAutoHeight', 'slideTo', 'slideNext', 'slidePrev', 'getActiveIndex', 'getPreviousIndex', 'length', 'isEnd', 'isBeginning', 'startAutoplay', 'stopAutoplay', 'lockSwipeToNext', 'lockSwipeToPrev', 'lockSwipes', 'getSwiper']\n  })], IonSlides);\n  return IonSlides;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonSpinner = /*#__PURE__*/(function () {\n  var IonSpinner = /*#__PURE__*/_createClass(function IonSpinner(c, r, z) {\n    _classCallCheck(this, IonSpinner);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  });\n\n  /** @nocollapse */\n  IonSpinner.ɵfac = function IonSpinner_Factory(t) {\n    return new (t || IonSpinner)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonSpinner.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonSpinner,\n    selectors: [[\"ion-spinner\"]],\n    inputs: {\n      color: \"color\",\n      duration: \"duration\",\n      name: \"name\",\n      paused: \"paused\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonSpinner_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonSpinner = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['color', 'duration', 'name', 'paused']\n  })], IonSpinner);\n  return IonSpinner;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonSplitPane = /*#__PURE__*/(function () {\n  var IonSplitPane = /*#__PURE__*/_createClass(function IonSplitPane(c, r, z) {\n    _classCallCheck(this, IonSplitPane);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, ['ionSplitPaneVisible']);\n  });\n\n  /** @nocollapse */\n  IonSplitPane.ɵfac = function IonSplitPane_Factory(t) {\n    return new (t || IonSplitPane)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonSplitPane.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonSplitPane,\n    selectors: [[\"ion-split-pane\"]],\n    inputs: {\n      contentId: \"contentId\",\n      disabled: \"disabled\",\n      when: \"when\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonSplitPane_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonSplitPane = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['contentId', 'disabled', 'when']\n  })], IonSplitPane);\n  return IonSplitPane;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonTabBar = /*#__PURE__*/(function () {\n  var IonTabBar = /*#__PURE__*/_createClass(function IonTabBar(c, r, z) {\n    _classCallCheck(this, IonTabBar);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  });\n\n  /** @nocollapse */\n  IonTabBar.ɵfac = function IonTabBar_Factory(t) {\n    return new (t || IonTabBar)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonTabBar.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonTabBar,\n    selectors: [[\"ion-tab-bar\"]],\n    inputs: {\n      color: \"color\",\n      mode: \"mode\",\n      selectedTab: \"selectedTab\",\n      translucent: \"translucent\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonTabBar_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonTabBar = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['color', 'mode', 'selectedTab', 'translucent']\n  })], IonTabBar);\n  return IonTabBar;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonTabButton = /*#__PURE__*/(function () {\n  var IonTabButton = /*#__PURE__*/_createClass(function IonTabButton(c, r, z) {\n    _classCallCheck(this, IonTabButton);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  });\n\n  /** @nocollapse */\n  IonTabButton.ɵfac = function IonTabButton_Factory(t) {\n    return new (t || IonTabButton)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonTabButton.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonTabButton,\n    selectors: [[\"ion-tab-button\"]],\n    inputs: {\n      disabled: \"disabled\",\n      download: \"download\",\n      href: \"href\",\n      layout: \"layout\",\n      mode: \"mode\",\n      rel: \"rel\",\n      selected: \"selected\",\n      tab: \"tab\",\n      target: \"target\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonTabButton_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonTabButton = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['disabled', 'download', 'href', 'layout', 'mode', 'rel', 'selected', 'tab', 'target']\n  })], IonTabButton);\n  return IonTabButton;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonText = /*#__PURE__*/(function () {\n  var IonText = /*#__PURE__*/_createClass(function IonText(c, r, z) {\n    _classCallCheck(this, IonText);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  });\n\n  /** @nocollapse */\n  IonText.ɵfac = function IonText_Factory(t) {\n    return new (t || IonText)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonText.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonText,\n    selectors: [[\"ion-text\"]],\n    inputs: {\n      color: \"color\",\n      mode: \"mode\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonText_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonText = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['color', 'mode']\n  })], IonText);\n  return IonText;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonTextarea = /*#__PURE__*/(function () {\n  var IonTextarea = /*#__PURE__*/_createClass(function IonTextarea(c, r, z) {\n    _classCallCheck(this, IonTextarea);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, ['ionChange', 'ionInput', 'ionBlur', 'ionFocus']);\n  });\n\n  /** @nocollapse */\n  IonTextarea.ɵfac = function IonTextarea_Factory(t) {\n    return new (t || IonTextarea)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonTextarea.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonTextarea,\n    selectors: [[\"ion-textarea\"]],\n    inputs: {\n      autoGrow: \"autoGrow\",\n      autocapitalize: \"autocapitalize\",\n      autofocus: \"autofocus\",\n      clearOnEdit: \"clearOnEdit\",\n      color: \"color\",\n      cols: \"cols\",\n      debounce: \"debounce\",\n      disabled: \"disabled\",\n      enterkeyhint: \"enterkeyhint\",\n      inputmode: \"inputmode\",\n      maxlength: \"maxlength\",\n      minlength: \"minlength\",\n      mode: \"mode\",\n      name: \"name\",\n      placeholder: \"placeholder\",\n      readonly: \"readonly\",\n      required: \"required\",\n      rows: \"rows\",\n      spellcheck: \"spellcheck\",\n      value: \"value\",\n      wrap: \"wrap\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonTextarea_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonTextarea = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['autoGrow', 'autocapitalize', 'autofocus', 'clearOnEdit', 'color', 'cols', 'debounce', 'disabled', 'enterkeyhint', 'inputmode', 'maxlength', 'minlength', 'mode', 'name', 'placeholder', 'readonly', 'required', 'rows', 'spellcheck', 'value', 'wrap'],\n    methods: ['setFocus', 'getInputElement']\n  })], IonTextarea);\n  return IonTextarea;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonThumbnail = /*#__PURE__*/(function () {\n  var IonThumbnail = /*#__PURE__*/_createClass(function IonThumbnail(c, r, z) {\n    _classCallCheck(this, IonThumbnail);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  });\n\n  /** @nocollapse */\n  IonThumbnail.ɵfac = function IonThumbnail_Factory(t) {\n    return new (t || IonThumbnail)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonThumbnail.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonThumbnail,\n    selectors: [[\"ion-thumbnail\"]],\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonThumbnail_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonThumbnail = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined\n  })], IonThumbnail);\n  return IonThumbnail;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonTitle = /*#__PURE__*/(function () {\n  var IonTitle = /*#__PURE__*/_createClass(function IonTitle(c, r, z) {\n    _classCallCheck(this, IonTitle);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  });\n\n  /** @nocollapse */\n  IonTitle.ɵfac = function IonTitle_Factory(t) {\n    return new (t || IonTitle)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonTitle.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonTitle,\n    selectors: [[\"ion-title\"]],\n    inputs: {\n      color: \"color\",\n      size: \"size\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonTitle_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonTitle = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['color', 'size']\n  })], IonTitle);\n  return IonTitle;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonToggle = /*#__PURE__*/(function () {\n  var IonToggle = /*#__PURE__*/_createClass(function IonToggle(c, r, z) {\n    _classCallCheck(this, IonToggle);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, ['ionChange', 'ionFocus', 'ionBlur']);\n  });\n\n  /** @nocollapse */\n  IonToggle.ɵfac = function IonToggle_Factory(t) {\n    return new (t || IonToggle)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonToggle.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonToggle,\n    selectors: [[\"ion-toggle\"]],\n    inputs: {\n      checked: \"checked\",\n      color: \"color\",\n      disabled: \"disabled\",\n      mode: \"mode\",\n      name: \"name\",\n      value: \"value\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonToggle_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonToggle = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['checked', 'color', 'disabled', 'mode', 'name', 'value']\n  })], IonToggle);\n  return IonToggle;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonToolbar = /*#__PURE__*/(function () {\n  var IonToolbar = /*#__PURE__*/_createClass(function IonToolbar(c, r, z) {\n    _classCallCheck(this, IonToolbar);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  });\n\n  /** @nocollapse */\n  IonToolbar.ɵfac = function IonToolbar_Factory(t) {\n    return new (t || IonToolbar)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonToolbar.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonToolbar,\n    selectors: [[\"ion-toolbar\"]],\n    inputs: {\n      color: \"color\",\n      mode: \"mode\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonToolbar_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonToolbar = __decorate([ProxyCmp({\n    defineCustomElementFn: undefined,\n    inputs: ['color', 'mode']\n  })], IonToolbar);\n  return IonToolbar;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @description\n * NavParams are an object that exists on a page and can contain data for that particular view.\n * Similar to how data was pass to a view in V1 with `$stateParams`, NavParams offer a much more flexible\n * option with a simple `get` method.\n *\n * @usage\n * ```ts\n * import { NavParams } from '@ionic/angular';\n *\n * export class MyClass{\n *\n *  constructor(navParams: NavParams){\n *    // userParams is an object we have in our nav-parameters\n *    navParams.get('userParams');\n *  }\n *\n * }\n * ```\n */\n\n\nvar NavParams = /*#__PURE__*/function () {\n  function NavParams() {\n    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, NavParams);\n\n    this.data = data;\n  }\n  /**\n   * Get the value of a nav-parameter for the current view\n   *\n   * ```ts\n   * import { NavParams } from 'ionic-angular';\n   *\n   * export class MyClass{\n   *  constructor(public navParams: NavParams){\n   *    // userParams is an object we have in our nav-parameters\n   *    this.navParams.get('userParams');\n   *  }\n   * }\n   * ```\n   *\n   * @param param Which param you want to look up\n   */\n\n\n  _createClass(NavParams, [{\n    key: \"get\",\n    value: function get(param) {\n      return this.data[param];\n    }\n  }]);\n\n  return NavParams;\n}();\n\nvar AngularDelegate = /*#__PURE__*/(function () {\n  var AngularDelegate = /*#__PURE__*/function () {\n    function AngularDelegate(zone, appRef) {\n      _classCallCheck(this, AngularDelegate);\n\n      this.zone = zone;\n      this.appRef = appRef;\n    }\n\n    _createClass(AngularDelegate, [{\n      key: \"create\",\n      value: function create(resolver, injector, location) {\n        return new AngularFrameworkDelegate(resolver, injector, location, this.appRef, this.zone);\n      }\n    }]);\n\n    return AngularDelegate;\n  }();\n\n  /** @nocollapse */\n  AngularDelegate.ɵfac = function AngularDelegate_Factory(t) {\n    return new (t || AngularDelegate)(i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i0.ApplicationRef));\n  };\n  /** @nocollapse */\n\n\n  AngularDelegate.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AngularDelegate,\n    factory: AngularDelegate.ɵfac\n  });\n  return AngularDelegate;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar AngularFrameworkDelegate = /*#__PURE__*/function () {\n  function AngularFrameworkDelegate(resolver, injector, location, appRef, zone) {\n    _classCallCheck(this, AngularFrameworkDelegate);\n\n    this.resolver = resolver;\n    this.injector = injector;\n    this.location = location;\n    this.appRef = appRef;\n    this.zone = zone;\n    this.elRefMap = new WeakMap();\n    this.elEventsMap = new WeakMap();\n  }\n\n  _createClass(AngularFrameworkDelegate, [{\n    key: \"attachViewToDom\",\n    value: function attachViewToDom(container, component, params, cssClasses) {\n      var _this4 = this;\n\n      return this.zone.run(function () {\n        return new Promise(function (resolve) {\n          var el = attachView(_this4.zone, _this4.resolver, _this4.injector, _this4.location, _this4.appRef, _this4.elRefMap, _this4.elEventsMap, container, component, params, cssClasses);\n          resolve(el);\n        });\n      });\n    }\n  }, {\n    key: \"removeViewFromDom\",\n    value: function removeViewFromDom(_container, component) {\n      var _this5 = this;\n\n      return this.zone.run(function () {\n        return new Promise(function (resolve) {\n          var componentRef = _this5.elRefMap.get(component);\n\n          if (componentRef) {\n            componentRef.destroy();\n\n            _this5.elRefMap.delete(component);\n\n            var unbindEvents = _this5.elEventsMap.get(component);\n\n            if (unbindEvents) {\n              unbindEvents();\n\n              _this5.elEventsMap.delete(component);\n            }\n          }\n\n          resolve();\n        });\n      });\n    }\n  }]);\n\n  return AngularFrameworkDelegate;\n}();\n\nvar attachView = function attachView(zone, resolver, injector, location, appRef, elRefMap, elEventsMap, container, component, params, cssClasses) {\n  var factory = resolver.resolveComponentFactory(component);\n  var childInjector = Injector.create({\n    providers: getProviders(params),\n    parent: injector\n  });\n  var componentRef = location ? location.createComponent(factory, location.length, childInjector) : factory.create(childInjector);\n  var instance = componentRef.instance;\n  var hostElement = componentRef.location.nativeElement;\n\n  if (params) {\n    Object.assign(instance, params);\n  }\n\n  if (cssClasses) {\n    var _iterator = _createForOfIteratorHelper(cssClasses),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var clazz = _step.value;\n        hostElement.classList.add(clazz);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n  var unbindEvents = bindLifecycleEvents(zone, instance, hostElement);\n  container.appendChild(hostElement);\n\n  if (!location) {\n    appRef.attachView(componentRef.hostView);\n  }\n\n  componentRef.changeDetectorRef.reattach();\n  elRefMap.set(hostElement, componentRef);\n  elEventsMap.set(hostElement, unbindEvents);\n  return hostElement;\n};\n\nvar LIFECYCLES = [LIFECYCLE_WILL_ENTER, LIFECYCLE_DID_ENTER, LIFECYCLE_WILL_LEAVE, LIFECYCLE_DID_LEAVE, LIFECYCLE_WILL_UNLOAD];\n\nvar bindLifecycleEvents = function bindLifecycleEvents(zone, instance, element) {\n  return zone.run(function () {\n    var unregisters = LIFECYCLES.filter(function (eventName) {\n      return typeof instance[eventName] === 'function';\n    }).map(function (eventName) {\n      var handler = function handler(ev) {\n        return instance[eventName](ev.detail);\n      };\n\n      element.addEventListener(eventName, handler);\n      return function () {\n        return element.removeEventListener(eventName, handler);\n      };\n    });\n    return function () {\n      return unregisters.forEach(function (fn) {\n        return fn();\n      });\n    };\n  });\n};\n\nvar NavParamsToken = new InjectionToken('NavParamsToken');\n\nvar getProviders = function getProviders(params) {\n  return [{\n    provide: NavParamsToken,\n    useValue: params\n  }, {\n    provide: NavParams,\n    useFactory: provideNavParamsInjectable,\n    deps: [NavParamsToken]\n  }];\n};\n\nvar provideNavParamsInjectable = function provideNavParamsInjectable(params) {\n  return new NavParams(params);\n};\n\nvar _insertView = function insertView(views, view, direction) {\n  if (direction === 'root') {\n    return setRoot(views, view);\n  } else if (direction === 'forward') {\n    return setForward(views, view);\n  } else {\n    return setBack(views, view);\n  }\n};\n\nvar setRoot = function setRoot(views, view) {\n  views = views.filter(function (v) {\n    return v.stackId !== view.stackId;\n  });\n  views.push(view);\n  return views;\n};\n\nvar setForward = function setForward(views, view) {\n  var index = views.indexOf(view);\n\n  if (index >= 0) {\n    views = views.filter(function (v) {\n      return v.stackId !== view.stackId || v.id <= view.id;\n    });\n  } else {\n    views.push(view);\n  }\n\n  return views;\n};\n\nvar setBack = function setBack(views, view) {\n  var index = views.indexOf(view);\n\n  if (index >= 0) {\n    return views.filter(function (v) {\n      return v.stackId !== view.stackId || v.id <= view.id;\n    });\n  } else {\n    return setRoot(views, view);\n  }\n};\n\nvar getUrl = function getUrl(router, activatedRoute) {\n  var urlTree = router.createUrlTree(['.'], {\n    relativeTo: activatedRoute\n  });\n  return router.serializeUrl(urlTree);\n};\n\nvar isTabSwitch = function isTabSwitch(enteringView, leavingView) {\n  if (!leavingView) {\n    return true;\n  }\n\n  return enteringView.stackId !== leavingView.stackId;\n};\n\nvar computeStackId = function computeStackId(prefixUrl, url) {\n  if (!prefixUrl) {\n    return undefined;\n  }\n\n  var segments = toSegments(url);\n\n  for (var i = 0; i < segments.length; i++) {\n    if (i >= prefixUrl.length) {\n      return segments[i];\n    }\n\n    if (segments[i] !== prefixUrl[i]) {\n      return undefined;\n    }\n  }\n\n  return undefined;\n};\n\nvar toSegments = function toSegments(path) {\n  return path.split('/').map(function (s) {\n    return s.trim();\n  }).filter(function (s) {\n    return s !== '';\n  });\n};\n\nvar destroyView = function destroyView(view) {\n  if (view) {\n    // TODO lifecycle event\n    view.ref.destroy();\n    view.unlistenEvents();\n  }\n};\n\nvar StackController = /*#__PURE__*/function () {\n  function StackController(tabsPrefix, containerEl, router, navCtrl, zone, location) {\n    _classCallCheck(this, StackController);\n\n    this.containerEl = containerEl;\n    this.router = router;\n    this.navCtrl = navCtrl;\n    this.zone = zone;\n    this.location = location;\n    this.views = [];\n    this.skipTransition = false;\n    this.nextId = 0;\n    this.tabsPrefix = tabsPrefix !== undefined ? toSegments(tabsPrefix) : undefined;\n  }\n\n  _createClass(StackController, [{\n    key: \"createView\",\n    value: function createView(ref, activatedRoute) {\n      var _a;\n\n      var url = getUrl(this.router, activatedRoute);\n      var element = (_a = ref === null || ref === void 0 ? void 0 : ref.location) === null || _a === void 0 ? void 0 : _a.nativeElement;\n      var unlistenEvents = bindLifecycleEvents(this.zone, ref.instance, element);\n      return {\n        id: this.nextId++,\n        stackId: computeStackId(this.tabsPrefix, url),\n        unlistenEvents: unlistenEvents,\n        element: element,\n        ref: ref,\n        url: url\n      };\n    }\n  }, {\n    key: \"getExistingView\",\n    value: function getExistingView(activatedRoute) {\n      var activatedUrlKey = getUrl(this.router, activatedRoute);\n      var view = this.views.find(function (vw) {\n        return vw.url === activatedUrlKey;\n      });\n\n      if (view) {\n        view.ref.changeDetectorRef.reattach();\n      }\n\n      return view;\n    }\n  }, {\n    key: \"setActive\",\n    value: function setActive(enteringView) {\n      var _this6 = this;\n\n      var _a, _b;\n\n      var consumeResult = this.navCtrl.consumeTransition();\n      var direction = consumeResult.direction,\n          animation = consumeResult.animation,\n          animationBuilder = consumeResult.animationBuilder;\n      var leavingView = this.activeView;\n      var tabSwitch = isTabSwitch(enteringView, leavingView);\n\n      if (tabSwitch) {\n        direction = 'back';\n        animation = undefined;\n      }\n\n      var viewsSnapshot = this.views.slice();\n      var currentNavigation;\n      var router = this.router; // Angular >= 7.2.0\n\n      if (router.getCurrentNavigation) {\n        currentNavigation = router.getCurrentNavigation(); // Angular < 7.2.0\n      } else if ((_a = router.navigations) === null || _a === void 0 ? void 0 : _a.value) {\n        currentNavigation = router.navigations.value;\n      }\n      /**\n       * If the navigation action\n       * sets `replaceUrl: true`\n       * then we need to make sure\n       * we remove the last item\n       * from our views stack\n       */\n\n\n      if ((_b = currentNavigation === null || currentNavigation === void 0 ? void 0 : currentNavigation.extras) === null || _b === void 0 ? void 0 : _b.replaceUrl) {\n        if (this.views.length > 0) {\n          this.views.splice(-1, 1);\n        }\n      }\n\n      var reused = this.views.includes(enteringView);\n      var views = this.insertView(enteringView, direction); // Trigger change detection before transition starts\n      // This will call ngOnInit() the first time too, just after the view\n      // was attached to the dom, but BEFORE the transition starts\n\n      if (!reused) {\n        enteringView.ref.changeDetectorRef.detectChanges();\n      }\n      /**\n       * If we are going back from a page that\n       * was presented using a custom animation\n       * we should default to using that\n       * unless the developer explicitly\n       * provided another animation.\n       */\n\n\n      var customAnimation = enteringView.animationBuilder;\n\n      if (animationBuilder === undefined && direction === 'back' && !tabSwitch && customAnimation !== undefined) {\n        animationBuilder = customAnimation;\n      }\n      /**\n       * Save any custom animation so that navigating\n       * back will use this custom animation by default.\n       */\n\n\n      if (leavingView) {\n        leavingView.animationBuilder = animationBuilder;\n      } // Wait until previous transitions finish\n\n\n      return this.zone.runOutsideAngular(function () {\n        return _this6.wait(function () {\n          // disconnect leaving page from change detection to\n          // reduce jank during the page transition\n          if (leavingView) {\n            leavingView.ref.changeDetectorRef.detach();\n          } // In case the enteringView is the same as the leavingPage we need to reattach()\n\n\n          enteringView.ref.changeDetectorRef.reattach();\n          return _this6.transition(enteringView, leavingView, animation, _this6.canGoBack(1), false, animationBuilder).then(function () {\n            return cleanupAsync(enteringView, views, viewsSnapshot, _this6.location, _this6.zone);\n          }).then(function () {\n            return {\n              enteringView: enteringView,\n              direction: direction,\n              animation: animation,\n              tabSwitch: tabSwitch\n            };\n          });\n        });\n      });\n    }\n  }, {\n    key: \"canGoBack\",\n    value: function canGoBack(deep) {\n      var stackId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getActiveStackId();\n      return this.getStack(stackId).length > deep;\n    }\n  }, {\n    key: \"pop\",\n    value: function pop(deep) {\n      var _this7 = this;\n\n      var stackId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getActiveStackId();\n      return this.zone.run(function () {\n        var _a, _b;\n\n        var views = _this7.getStack(stackId);\n\n        if (views.length <= deep) {\n          return Promise.resolve(false);\n        }\n\n        var view = views[views.length - deep - 1];\n        var url = view.url;\n        var viewSavedData = view.savedData;\n\n        if (viewSavedData) {\n          var primaryOutlet = viewSavedData.get('primary');\n\n          if ((_b = (_a = primaryOutlet === null || primaryOutlet === void 0 ? void 0 : primaryOutlet.route) === null || _a === void 0 ? void 0 : _a._routerState) === null || _b === void 0 ? void 0 : _b.snapshot.url) {\n            url = primaryOutlet.route._routerState.snapshot.url;\n          }\n        }\n\n        var _this7$navCtrl$consum = _this7.navCtrl.consumeTransition(),\n            animationBuilder = _this7$navCtrl$consum.animationBuilder;\n\n        return _this7.navCtrl.navigateBack(url, Object.assign(Object.assign({}, view.savedExtras), {\n          animation: animationBuilder\n        })).then(function () {\n          return true;\n        });\n      });\n    }\n  }, {\n    key: \"startBackTransition\",\n    value: function startBackTransition() {\n      var _this8 = this;\n\n      var leavingView = this.activeView;\n\n      if (leavingView) {\n        var views = this.getStack(leavingView.stackId);\n        var enteringView = views[views.length - 2];\n        var customAnimation = enteringView.animationBuilder;\n        return this.wait(function () {\n          return _this8.transition(enteringView, // entering view\n          leavingView, // leaving view\n          'back', _this8.canGoBack(2), true, customAnimation);\n        });\n      }\n\n      return Promise.resolve();\n    }\n  }, {\n    key: \"endBackTransition\",\n    value: function endBackTransition(shouldComplete) {\n      if (shouldComplete) {\n        this.skipTransition = true;\n        this.pop(1);\n      } else if (this.activeView) {\n        cleanup(this.activeView, this.views, this.views, this.location, this.zone);\n      }\n    }\n  }, {\n    key: \"getLastUrl\",\n    value: function getLastUrl(stackId) {\n      var views = this.getStack(stackId);\n      return views.length > 0 ? views[views.length - 1] : undefined;\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"getRootUrl\",\n    value: function getRootUrl(stackId) {\n      var views = this.getStack(stackId);\n      return views.length > 0 ? views[0] : undefined;\n    }\n  }, {\n    key: \"getActiveStackId\",\n    value: function getActiveStackId() {\n      return this.activeView ? this.activeView.stackId : undefined;\n    }\n  }, {\n    key: \"hasRunningTask\",\n    value: function hasRunningTask() {\n      return this.runningTask !== undefined;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      this.containerEl = undefined;\n      this.views.forEach(destroyView);\n      this.activeView = undefined;\n      this.views = [];\n    }\n  }, {\n    key: \"getStack\",\n    value: function getStack(stackId) {\n      return this.views.filter(function (v) {\n        return v.stackId === stackId;\n      });\n    }\n  }, {\n    key: \"insertView\",\n    value: function insertView(enteringView, direction) {\n      this.activeView = enteringView;\n      this.views = _insertView(this.views, enteringView, direction);\n      return this.views.slice();\n    }\n  }, {\n    key: \"transition\",\n    value: function transition(enteringView, leavingView, direction, showGoBack, progressAnimation, animationBuilder) {\n      if (this.skipTransition) {\n        this.skipTransition = false;\n        return Promise.resolve(false);\n      }\n\n      if (leavingView === enteringView) {\n        return Promise.resolve(false);\n      }\n\n      var enteringEl = enteringView ? enteringView.element : undefined;\n      var leavingEl = leavingView ? leavingView.element : undefined;\n      var containerEl = this.containerEl;\n\n      if (enteringEl && enteringEl !== leavingEl) {\n        enteringEl.classList.add('ion-page');\n        enteringEl.classList.add('ion-page-invisible');\n\n        if (enteringEl.parentElement !== containerEl) {\n          containerEl.appendChild(enteringEl);\n        }\n\n        if (containerEl.commit) {\n          return containerEl.commit(enteringEl, leavingEl, {\n            deepWait: true,\n            duration: direction === undefined ? 0 : undefined,\n            direction: direction,\n            showGoBack: showGoBack,\n            progressAnimation: progressAnimation,\n            animationBuilder: animationBuilder\n          });\n        }\n      }\n\n      return Promise.resolve(false);\n    }\n  }, {\n    key: \"wait\",\n    value: function wait(task) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var _this9 = this;\n\n        var promise;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(this.runningTask !== undefined)) {\n                  _context.next = 4;\n                  break;\n                }\n\n                _context.next = 3;\n                return this.runningTask;\n\n              case 3:\n                this.runningTask = undefined;\n\n              case 4:\n                promise = this.runningTask = task();\n                promise.finally(function () {\n                  return _this9.runningTask = undefined;\n                });\n                return _context.abrupt(\"return\", promise);\n\n              case 7:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n  }]);\n\n  return StackController;\n}();\n\nvar cleanupAsync = function cleanupAsync(activeRoute, views, viewsSnapshot, location, zone) {\n  if (typeof requestAnimationFrame === 'function') {\n    return new Promise(function (resolve) {\n      requestAnimationFrame(function () {\n        cleanup(activeRoute, views, viewsSnapshot, location, zone);\n        resolve();\n      });\n    });\n  }\n\n  return Promise.resolve();\n};\n\nvar cleanup = function cleanup(activeRoute, views, viewsSnapshot, location, zone) {\n  /**\n   * Re-enter the Angular zone when destroying page components. This will allow\n   * lifecycle events (`ngOnDestroy`) to be run inside the Angular zone.\n   */\n  zone.run(function () {\n    return viewsSnapshot.filter(function (view) {\n      return !views.includes(view);\n    }).forEach(destroyView);\n  });\n  views.forEach(function (view) {\n    /**\n     * In the event that a user navigated multiple\n     * times in rapid succession, we want to make sure\n     * we don't pre-emptively detach a view while\n     * it is in mid-transition.\n     *\n     * In this instance we also do not care about query\n     * params or fragments as it will be the same view regardless\n     */\n    var locationWithoutParams = location.path().split('?')[0];\n    var locationWithoutFragment = locationWithoutParams.split('#')[0];\n\n    if (view !== activeRoute && view.url !== locationWithoutFragment) {\n      var element = view.element;\n      element.setAttribute('aria-hidden', 'true');\n      element.classList.add('ion-page-hidden');\n      view.ref.changeDetectorRef.detach();\n    }\n  });\n};\n\nvar Config = /*#__PURE__*/(function () {\n  var Config = /*#__PURE__*/function () {\n    function Config() {\n      _classCallCheck(this, Config);\n    }\n\n    _createClass(Config, [{\n      key: \"get\",\n      value: function get(key, fallback) {\n        var c = getConfig();\n\n        if (c) {\n          return c.get(key, fallback);\n        }\n\n        return null;\n      }\n    }, {\n      key: \"getBoolean\",\n      value: function getBoolean(key, fallback) {\n        var c = getConfig();\n\n        if (c) {\n          return c.getBoolean(key, fallback);\n        }\n\n        return false;\n      }\n    }, {\n      key: \"getNumber\",\n      value: function getNumber(key, fallback) {\n        var c = getConfig();\n\n        if (c) {\n          return c.getNumber(key, fallback);\n        }\n\n        return 0;\n      }\n    }]);\n\n    return Config;\n  }();\n\n  /** @nocollapse */\n  Config.ɵfac = function Config_Factory(t) {\n    return new (t || Config)();\n  };\n  /** @nocollapse */\n\n\n  Config.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: Config,\n    factory: Config.ɵfac,\n    providedIn: 'root'\n  });\n  return Config;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar ConfigToken = new InjectionToken('USERCONFIG');\n\nvar getConfig = function getConfig() {\n  if (typeof window !== 'undefined') {\n    var Ionic = window.Ionic;\n\n    if (Ionic === null || Ionic === void 0 ? void 0 : Ionic.config) {\n      return Ionic.config;\n    }\n  }\n\n  return null;\n};\n\nvar Platform = /*#__PURE__*/(function () {\n  var Platform = /*#__PURE__*/function () {\n    function Platform(doc, zone) {\n      var _this10 = this;\n\n      _classCallCheck(this, Platform);\n\n      this.doc = doc;\n      /**\n       * @hidden\n       */\n\n      this.backButton = new Subject();\n      /**\n       * The keyboardDidShow event emits when the\n       * on-screen keyboard is presented.\n       */\n\n      this.keyboardDidShow = new Subject();\n      /**\n       * The keyboardDidHide event emits when the\n       * on-screen keyboard is hidden.\n       */\n\n      this.keyboardDidHide = new Subject();\n      /**\n       * The pause event emits when the native platform puts the application\n       * into the background, typically when the user switches to a different\n       * application. This event would emit when a Cordova app is put into\n       * the background, however, it would not fire on a standard web browser.\n       */\n\n      this.pause = new Subject();\n      /**\n       * The resume event emits when the native platform pulls the application\n       * out from the background. This event would emit when a Cordova app comes\n       * out from the background, however, it would not fire on a standard web browser.\n       */\n\n      this.resume = new Subject();\n      /**\n       * The resize event emits when the browser window has changed dimensions. This\n       * could be from a browser window being physically resized, or from a device\n       * changing orientation.\n       */\n\n      this.resize = new Subject();\n      zone.run(function () {\n        var _a;\n\n        _this10.win = doc.defaultView;\n\n        _this10.backButton.subscribeWithPriority = function (priority, callback) {\n          return this.subscribe(function (ev) {\n            return ev.register(priority, function (processNextHandler) {\n              return zone.run(function () {\n                return callback(processNextHandler);\n              });\n            });\n          });\n        };\n\n        proxyEvent(_this10.pause, doc, 'pause');\n        proxyEvent(_this10.resume, doc, 'resume');\n        proxyEvent(_this10.backButton, doc, 'ionBackButton');\n        proxyEvent(_this10.resize, _this10.win, 'resize');\n        proxyEvent(_this10.keyboardDidShow, _this10.win, 'ionKeyboardDidShow');\n        proxyEvent(_this10.keyboardDidHide, _this10.win, 'ionKeyboardDidHide');\n        var readyResolve;\n        _this10._readyPromise = new Promise(function (res) {\n          readyResolve = res;\n        });\n\n        if ((_a = _this10.win) === null || _a === void 0 ? void 0 : _a['cordova']) {\n          doc.addEventListener('deviceready', function () {\n            readyResolve('cordova');\n          }, {\n            once: true\n          });\n        } else {\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          readyResolve('dom');\n        }\n      });\n    }\n    /**\n     * @returns returns true/false based on platform.\n     * @description\n     * Depending on the platform the user is on, `is(platformName)` will\n     * return `true` or `false`. Note that the same app can return `true`\n     * for more than one platform name. For example, an app running from\n     * an iPad would return `true` for the platform names: `mobile`,\n     * `ios`, `ipad`, and `tablet`. Additionally, if the app was running\n     * from Cordova then `cordova` would be true, and if it was running\n     * from a web browser on the iPad then `mobileweb` would be `true`.\n     *\n     * ```\n     * import { Platform } from 'ionic-angular';\n     *\n     * @Component({...})\n     * export MyPage {\n     *   constructor(public platform: Platform) {\n     *     if (this.platform.is('ios')) {\n     *       // This will only print when on iOS\n     *       console.log('I am an iOS device!');\n     *     }\n     *   }\n     * }\n     * ```\n     *\n     * | Platform Name   | Description                        |\n     * |-----------------|------------------------------------|\n     * | android         | on a device running Android.       |\n     * | capacitor       | on a device running Capacitor.     |\n     * | cordova         | on a device running Cordova.       |\n     * | ios             | on a device running iOS.           |\n     * | ipad            | on an iPad device.                 |\n     * | iphone          | on an iPhone device.               |\n     * | phablet         | on a phablet device.               |\n     * | tablet          | on a tablet device.                |\n     * | electron        | in Electron on a desktop device.   |\n     * | pwa             | as a PWA app.                      |\n     * | mobile          | on a mobile device.                |\n     * | mobileweb       | on a mobile device in a browser.   |\n     * | desktop         | on a desktop device.               |\n     * | hybrid          | is a cordova or capacitor app.     |\n     *\n     */\n\n\n    _createClass(Platform, [{\n      key: \"is\",\n      value: function is(platformName) {\n        return isPlatform(this.win, platformName);\n      }\n      /**\n       * @returns the array of platforms\n       * @description\n       * Depending on what device you are on, `platforms` can return multiple values.\n       * Each possible value is a hierarchy of platforms. For example, on an iPhone,\n       * it would return `mobile`, `ios`, and `iphone`.\n       *\n       * ```\n       * import { Platform } from 'ionic-angular';\n       *\n       * @Component({...})\n       * export MyPage {\n       *   constructor(public platform: Platform) {\n       *     // This will print an array of the current platforms\n       *     console.log(this.platform.platforms());\n       *   }\n       * }\n       * ```\n       */\n\n    }, {\n      key: \"platforms\",\n      value: function platforms() {\n        return getPlatforms(this.win);\n      }\n      /**\n       * Returns a promise when the platform is ready and native functionality\n       * can be called. If the app is running from within a web browser, then\n       * the promise will resolve when the DOM is ready. When the app is running\n       * from an application engine such as Cordova, then the promise will\n       * resolve when Cordova triggers the `deviceready` event.\n       *\n       * The resolved value is the `readySource`, which states which platform\n       * ready was used. For example, when Cordova is ready, the resolved ready\n       * source is `cordova`. The default ready source value will be `dom`. The\n       * `readySource` is useful if different logic should run depending on the\n       * platform the app is running from. For example, only Cordova can execute\n       * the status bar plugin, so the web should not run status bar plugin logic.\n       *\n       * ```\n       * import { Component } from '@angular/core';\n       * import { Platform } from 'ionic-angular';\n       *\n       * @Component({...})\n       * export MyApp {\n       *   constructor(public platform: Platform) {\n       *     this.platform.ready().then((readySource) => {\n       *       console.log('Platform ready from', readySource);\n       *       // Platform now ready, execute any required native code\n       *     });\n       *   }\n       * }\n       * ```\n       */\n\n    }, {\n      key: \"ready\",\n      value: function ready() {\n        return this._readyPromise;\n      }\n      /**\n       * Returns if this app is using right-to-left language direction or not.\n       * We recommend the app's `index.html` file already has the correct `dir`\n       * attribute value set, such as `<html dir=\"ltr\">` or `<html dir=\"rtl\">`.\n       * [W3C: Structural markup and right-to-left text in HTML](http://www.w3.org/International/questions/qa-html-dir)\n       */\n\n    }, {\n      key: \"isRTL\",\n      get: function get() {\n        return this.doc.dir === 'rtl';\n      }\n      /**\n       * Get the query string parameter\n       */\n\n    }, {\n      key: \"getQueryParam\",\n      value: function getQueryParam(key) {\n        return readQueryParam(this.win.location.href, key);\n      }\n      /**\n       * Returns `true` if the app is in landscape mode.\n       */\n\n    }, {\n      key: \"isLandscape\",\n      value: function isLandscape() {\n        return !this.isPortrait();\n      }\n      /**\n       * Returns `true` if the app is in portrait mode.\n       */\n\n    }, {\n      key: \"isPortrait\",\n      value: function isPortrait() {\n        var _a, _b;\n\n        return (_b = (_a = this.win).matchMedia) === null || _b === void 0 ? void 0 : _b.call(_a, '(orientation: portrait)').matches;\n      }\n    }, {\n      key: \"testUserAgent\",\n      value: function testUserAgent(expression) {\n        var nav = this.win.navigator;\n        return !!((nav === null || nav === void 0 ? void 0 : nav.userAgent) && nav.userAgent.indexOf(expression) >= 0);\n      }\n      /**\n       * Get the current url.\n       */\n\n    }, {\n      key: \"url\",\n      value: function url() {\n        return this.win.location.href;\n      }\n      /**\n       * Gets the width of the platform's viewport using `window.innerWidth`.\n       */\n\n    }, {\n      key: \"width\",\n      value: function width() {\n        return this.win.innerWidth;\n      }\n      /**\n       * Gets the height of the platform's viewport using `window.innerHeight`.\n       */\n\n    }, {\n      key: \"height\",\n      value: function height() {\n        return this.win.innerHeight;\n      }\n    }]);\n\n    return Platform;\n  }();\n\n  /** @nocollapse */\n  Platform.ɵfac = function Platform_Factory(t) {\n    return new (t || Platform)(i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  Platform.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: Platform,\n    factory: Platform.ɵfac,\n    providedIn: 'root'\n  });\n  return Platform;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar readQueryParam = function readQueryParam(url, key) {\n  key = key.replace(/[[]/, '\\\\[').replace(/[\\]]/, '\\\\]');\n  var regex = new RegExp('[\\\\?&]' + key + '=([^&#]*)');\n  var results = regex.exec(url);\n  return results ? decodeURIComponent(results[1].replace(/\\+/g, ' ')) : null;\n};\n\nvar proxyEvent = function proxyEvent(emitter, el, eventName) {\n  if (el) {\n    el.addEventListener(eventName, function (ev) {\n      // ?? cordova might emit \"null\" events\n      emitter.next(ev != null ? ev.detail : undefined);\n    });\n  }\n};\n\nvar NavController = /*#__PURE__*/(function () {\n  var NavController = /*#__PURE__*/function () {\n    function NavController(platform, location, serializer, router) {\n      var _this11 = this;\n\n      _classCallCheck(this, NavController);\n\n      this.location = location;\n      this.serializer = serializer;\n      this.router = router;\n      this.direction = DEFAULT_DIRECTION;\n      this.animated = DEFAULT_ANIMATED;\n      this.guessDirection = 'forward';\n      this.lastNavId = -1; // Subscribe to router events to detect direction\n\n      if (router) {\n        router.events.subscribe(function (ev) {\n          if (ev instanceof NavigationStart) {\n            var id = ev.restoredState ? ev.restoredState.navigationId : ev.id;\n            _this11.guessDirection = id < _this11.lastNavId ? 'back' : 'forward';\n            _this11.guessAnimation = !ev.restoredState ? _this11.guessDirection : undefined;\n            _this11.lastNavId = _this11.guessDirection === 'forward' ? ev.id : id;\n          }\n        });\n      } // Subscribe to backButton events\n\n\n      platform.backButton.subscribeWithPriority(0, function (processNextHandler) {\n        _this11.pop();\n\n        processNextHandler();\n      });\n    }\n    /**\n     * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,\n     * it's equivalent to calling `this.router.navigateByUrl()`, but it's explicit about the **direction** of the transition.\n     *\n     * Going **forward** means that a new page is going to be pushed to the stack of the outlet (ion-router-outlet),\n     * and that it will show a \"forward\" animation by default.\n     *\n     * Navigating forward can also be triggered in a declarative manner by using the `[routerDirection]` directive:\n     *\n     * ```html\n     * <a routerLink=\"/path/to/page\" routerDirection=\"forward\">Link</a>\n     * ```\n     */\n\n\n    _createClass(NavController, [{\n      key: \"navigateForward\",\n      value: function navigateForward(url) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        this.setDirection('forward', options.animated, options.animationDirection, options.animation);\n        return this.navigate(url, options);\n      }\n      /**\n       * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,\n       * it's equivalent to calling:\n       *\n       * ```ts\n       * this.navController.setDirection('back');\n       * this.router.navigateByUrl(path);\n       * ```\n       *\n       * Going **back** means that all the pages in the stack until the navigated page is found will be popped,\n       * and that it will show a \"back\" animation by default.\n       *\n       * Navigating back can also be triggered in a declarative manner by using the `[routerDirection]` directive:\n       *\n       * ```html\n       * <a routerLink=\"/path/to/page\" routerDirection=\"back\">Link</a>\n       * ```\n       */\n\n    }, {\n      key: \"navigateBack\",\n      value: function navigateBack(url) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        this.setDirection('back', options.animated, options.animationDirection, options.animation);\n        return this.navigate(url, options);\n      }\n      /**\n       * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,\n       * it's equivalent to calling:\n       *\n       * ```ts\n       * this.navController.setDirection('root');\n       * this.router.navigateByUrl(path);\n       * ```\n       *\n       * Going **root** means that all existing pages in the stack will be removed,\n       * and the navigated page will become the single page in the stack.\n       *\n       * Navigating root can also be triggered in a declarative manner by using the `[routerDirection]` directive:\n       *\n       * ```html\n       * <a routerLink=\"/path/to/page\" routerDirection=\"root\">Link</a>\n       * ```\n       */\n\n    }, {\n      key: \"navigateRoot\",\n      value: function navigateRoot(url) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        this.setDirection('root', options.animated, options.animationDirection, options.animation);\n        return this.navigate(url, options);\n      }\n      /**\n       * Same as [Location](https://angular.io/api/common/Location)'s back() method.\n       * It will use the standard `window.history.back()` under the hood, but featuring a `back` animation\n       * by default.\n       */\n\n    }, {\n      key: \"back\",\n      value: function back() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n          animated: true,\n          animationDirection: 'back'\n        };\n        this.setDirection('back', options.animated, options.animationDirection, options.animation);\n        return this.location.back();\n      }\n      /**\n       * This methods goes back in the context of Ionic's stack navigation.\n       *\n       * It recursively finds the top active `ion-router-outlet` and calls `pop()`.\n       * This is the recommended way to go back when you are using `ion-router-outlet`.\n       */\n\n    }, {\n      key: \"pop\",\n      value: function pop() {\n        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n          var outlet;\n          return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  outlet = this.topOutlet;\n\n                case 1:\n                  if (!outlet) {\n                    _context2.next = 11;\n                    break;\n                  }\n\n                  _context2.next = 4;\n                  return outlet.pop();\n\n                case 4:\n                  if (!_context2.sent) {\n                    _context2.next = 8;\n                    break;\n                  }\n\n                  return _context2.abrupt(\"break\", 11);\n\n                case 8:\n                  outlet = outlet.parentOutlet;\n\n                case 9:\n                  _context2.next = 1;\n                  break;\n\n                case 11:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2, this);\n        }));\n      }\n      /**\n       * This methods specifies the direction of the next navigation performed by the Angular router.\n       *\n       * `setDirection()` does not trigger any transition, it just sets some flags to be consumed by `ion-router-outlet`.\n       *\n       * It's recommended to use `navigateForward()`, `navigateBack()` and `navigateRoot()` instead of `setDirection()`.\n       */\n\n    }, {\n      key: \"setDirection\",\n      value: function setDirection(direction, animated, animationDirection, animationBuilder) {\n        this.direction = direction;\n        this.animated = getAnimation(direction, animated, animationDirection);\n        this.animationBuilder = animationBuilder;\n      }\n      /**\n       * @internal\n       */\n\n    }, {\n      key: \"setTopOutlet\",\n      value: function setTopOutlet(outlet) {\n        this.topOutlet = outlet;\n      }\n      /**\n       * @internal\n       */\n\n    }, {\n      key: \"consumeTransition\",\n      value: function consumeTransition() {\n        var direction = 'root';\n        var animation;\n        var animationBuilder = this.animationBuilder;\n\n        if (this.direction === 'auto') {\n          direction = this.guessDirection;\n          animation = this.guessAnimation;\n        } else {\n          animation = this.animated;\n          direction = this.direction;\n        }\n\n        this.direction = DEFAULT_DIRECTION;\n        this.animated = DEFAULT_ANIMATED;\n        this.animationBuilder = undefined;\n        return {\n          direction: direction,\n          animation: animation,\n          animationBuilder: animationBuilder\n        };\n      }\n    }, {\n      key: \"navigate\",\n      value: function navigate(url, options) {\n        if (Array.isArray(url)) {\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          return this.router.navigate(url, options);\n        } else {\n          /**\n           * navigateByUrl ignores any properties that\n           * would change the url, so things like queryParams\n           * would be ignored unless we create a url tree\n           * More Info: https://github.com/angular/angular/issues/18798\n           */\n          var urlTree = this.serializer.parse(url.toString());\n\n          if (options.queryParams !== undefined) {\n            urlTree.queryParams = Object.assign({}, options.queryParams);\n          }\n\n          if (options.fragment !== undefined) {\n            urlTree.fragment = options.fragment;\n          }\n          /**\n           * `navigateByUrl` will still apply `NavigationExtras` properties\n           * that do not modify the url, such as `replaceUrl` which is why\n           * `options` is passed in here.\n           */\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n\n          return this.router.navigateByUrl(urlTree, options);\n        }\n      }\n    }]);\n\n    return NavController;\n  }();\n\n  /** @nocollapse */\n  NavController.ɵfac = function NavController_Factory(t) {\n    return new (t || NavController)(i0.ɵɵinject(Platform), i0.ɵɵinject(i1.Location), i0.ɵɵinject(i3.UrlSerializer), i0.ɵɵinject(i3.Router, 8));\n  };\n  /** @nocollapse */\n\n\n  NavController.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NavController,\n    factory: NavController.ɵfac,\n    providedIn: 'root'\n  });\n  return NavController;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar getAnimation = function getAnimation(direction, animated, animationDirection) {\n  if (animated === false) {\n    return undefined;\n  }\n\n  if (animationDirection !== undefined) {\n    return animationDirection;\n  }\n\n  if (direction === 'forward' || direction === 'back') {\n    return direction;\n  } else if (direction === 'root' && animated === true) {\n    return 'forward';\n  }\n\n  return undefined;\n};\n\nvar DEFAULT_DIRECTION = 'auto';\nvar DEFAULT_ANIMATED = undefined; // eslint-disable-next-line @angular-eslint/directive-class-suffix\n\nvar IonRouterOutlet = /*#__PURE__*/(function () {\n  var IonRouterOutlet = /*#__PURE__*/function () {\n    function IonRouterOutlet(parentContexts, location, resolver, name, tabs, config, navCtrl, commonLocation, elementRef, router, zone, activatedRoute, parentOutlet) {\n      _classCallCheck(this, IonRouterOutlet);\n\n      this.parentContexts = parentContexts;\n      this.location = location;\n      this.resolver = resolver;\n      this.config = config;\n      this.navCtrl = navCtrl;\n      this.parentOutlet = parentOutlet;\n      this.activated = null;\n      this.activatedView = null;\n      this._activatedRoute = null; // Maintain map of activated route proxies for each component instance\n\n      this.proxyMap = new WeakMap(); // Keep the latest activated route in a subject for the proxy routes to switch map to\n\n      this.currentActivatedRoute$ = new BehaviorSubject(null);\n      this.stackEvents = new EventEmitter(); // eslint-disable-next-line @angular-eslint/no-output-rename\n\n      this.activateEvents = new EventEmitter(); // eslint-disable-next-line @angular-eslint/no-output-rename\n\n      this.deactivateEvents = new EventEmitter();\n      this.nativeEl = elementRef.nativeElement;\n      this.name = name || PRIMARY_OUTLET;\n      this.tabsPrefix = tabs === 'true' ? getUrl(router, activatedRoute) : undefined;\n      this.stackCtrl = new StackController(this.tabsPrefix, this.nativeEl, router, navCtrl, zone, commonLocation);\n      parentContexts.onChildOutletCreated(this.name, this);\n    }\n\n    _createClass(IonRouterOutlet, [{\n      key: \"animation\",\n      set: function set(animation) {\n        this.nativeEl.animation = animation;\n      }\n    }, {\n      key: \"animated\",\n      set: function set(animated) {\n        this.nativeEl.animated = animated;\n      }\n    }, {\n      key: \"swipeGesture\",\n      set: function set(swipe) {\n        var _this12 = this;\n\n        this._swipeGesture = swipe;\n        this.nativeEl.swipeHandler = swipe ? {\n          canStart: function canStart() {\n            return _this12.stackCtrl.canGoBack(1) && !_this12.stackCtrl.hasRunningTask();\n          },\n          onStart: function onStart() {\n            return _this12.stackCtrl.startBackTransition();\n          },\n          onEnd: function onEnd(shouldContinue) {\n            return _this12.stackCtrl.endBackTransition(shouldContinue);\n          }\n        } : undefined;\n      }\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.stackCtrl.destroy();\n      }\n    }, {\n      key: \"getContext\",\n      value: function getContext() {\n        return this.parentContexts.getContext(this.name);\n      }\n    }, {\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        var _this13 = this;\n\n        if (!this.activated) {\n          // If the outlet was not instantiated at the time the route got activated we need to populate\n          // the outlet when it is initialized (ie inside a NgIf)\n          var context = this.getContext();\n\n          if (context === null || context === void 0 ? void 0 : context.route) {\n            this.activateWith(context.route, context.resolver || null);\n          }\n        }\n\n        new Promise(function (resolve) {\n          return componentOnReady(_this13.nativeEl, resolve);\n        }).then(function () {\n          if (_this13._swipeGesture === undefined) {\n            _this13.swipeGesture = _this13.config.getBoolean('swipeBackEnabled', _this13.nativeEl.mode === 'ios');\n          }\n        });\n      }\n    }, {\n      key: \"isActivated\",\n      get: function get() {\n        return !!this.activated;\n      }\n    }, {\n      key: \"component\",\n      get: function get() {\n        if (!this.activated) {\n          throw new Error('Outlet is not activated');\n        }\n\n        return this.activated.instance;\n      }\n    }, {\n      key: \"activatedRoute\",\n      get: function get() {\n        if (!this.activated) {\n          throw new Error('Outlet is not activated');\n        }\n\n        return this._activatedRoute;\n      }\n    }, {\n      key: \"activatedRouteData\",\n      get: function get() {\n        if (this._activatedRoute) {\n          return this._activatedRoute.snapshot.data;\n        }\n\n        return {};\n      }\n      /**\n       * Called when the `RouteReuseStrategy` instructs to detach the subtree\n       */\n\n    }, {\n      key: \"detach\",\n      value: function detach() {\n        throw new Error('incompatible reuse strategy');\n      }\n      /**\n       * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree\n       */\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n    }, {\n      key: \"attach\",\n      value: function attach(_ref, _activatedRoute) {\n        throw new Error('incompatible reuse strategy');\n      }\n    }, {\n      key: \"deactivate\",\n      value: function deactivate() {\n        if (this.activated) {\n          if (this.activatedView) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            var context = this.getContext();\n            this.activatedView.savedData = new Map(context.children['contexts']);\n            /**\n             * Angular v11.2.10 introduced a change\n             * where this route context is cleared out when\n             * a router-outlet is deactivated, However,\n             * we need this route information in order to\n             * return a user back to the correct tab when\n             * leaving and then going back to the tab context.\n             */\n\n            var primaryOutlet = this.activatedView.savedData.get('primary');\n\n            if (primaryOutlet && context.route) {\n              primaryOutlet.route = Object.assign({}, context.route);\n            }\n            /**\n             * Ensure we are saving the NavigationExtras\n             * data otherwise it will be lost\n             */\n\n\n            this.activatedView.savedExtras = {};\n\n            if (context.route) {\n              var contextSnapshot = context.route.snapshot;\n              this.activatedView.savedExtras.queryParams = contextSnapshot.queryParams;\n              this.activatedView.savedExtras.fragment = contextSnapshot.fragment;\n            }\n          }\n\n          var c = this.component;\n          this.activatedView = null;\n          this.activated = null;\n          this._activatedRoute = null;\n          this.deactivateEvents.emit(c);\n        }\n      }\n    }, {\n      key: \"activateWith\",\n      value: function activateWith(activatedRoute, resolver) {\n        var _this14 = this;\n\n        if (this.isActivated) {\n          throw new Error('Cannot activate an already activated outlet');\n        }\n\n        this._activatedRoute = activatedRoute;\n        var cmpRef;\n        var enteringView = this.stackCtrl.getExistingView(activatedRoute);\n\n        if (enteringView) {\n          cmpRef = this.activated = enteringView.ref;\n          var saved = enteringView.savedData;\n\n          if (saved) {\n            // self-restore\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            var context = this.getContext();\n            context.children['contexts'] = saved;\n          } // Updated activated route proxy for this component\n\n\n          this.updateActivatedRouteProxy(cmpRef.instance, activatedRoute);\n        } else {\n          var snapshot = activatedRoute._futureSnapshot; // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n          var component = snapshot.routeConfig.component;\n          resolver = resolver || this.resolver;\n          var factory = resolver.resolveComponentFactory(component);\n          var childContexts = this.parentContexts.getOrCreateContext(this.name).children; // We create an activated route proxy object that will maintain future updates for this component\n          // over its lifecycle in the stack.\n\n          var component$ = new BehaviorSubject(null);\n          var activatedRouteProxy = this.createActivatedRouteProxy(component$, activatedRoute);\n          var injector = new OutletInjector(activatedRouteProxy, childContexts, this.location.injector);\n          cmpRef = this.activated = this.location.createComponent(factory, this.location.length, injector); // Once the component is created we can push it to our local subject supplied to the proxy\n\n          component$.next(cmpRef.instance); // Calling `markForCheck` to make sure we will run the change detection when the\n          // `RouterOutlet` is inside a `ChangeDetectionStrategy.OnPush` component.\n\n          enteringView = this.stackCtrl.createView(this.activated, activatedRoute); // Store references to the proxy by component\n\n          this.proxyMap.set(cmpRef.instance, activatedRouteProxy);\n          this.currentActivatedRoute$.next({\n            component: cmpRef.instance,\n            activatedRoute: activatedRoute\n          });\n        }\n\n        this.activatedView = enteringView;\n        this.stackCtrl.setActive(enteringView).then(function (data) {\n          _this14.navCtrl.setTopOutlet(_this14);\n\n          _this14.activateEvents.emit(cmpRef.instance);\n\n          _this14.stackEvents.emit(data);\n        });\n      }\n      /**\n       * Returns `true` if there are pages in the stack to go back.\n       */\n\n    }, {\n      key: \"canGoBack\",\n      value: function canGoBack() {\n        var deep = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n        var stackId = arguments.length > 1 ? arguments[1] : undefined;\n        return this.stackCtrl.canGoBack(deep, stackId);\n      }\n      /**\n       * Resolves to `true` if it the outlet was able to sucessfully pop the last N pages.\n       */\n\n    }, {\n      key: \"pop\",\n      value: function pop() {\n        var deep = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n        var stackId = arguments.length > 1 ? arguments[1] : undefined;\n        return this.stackCtrl.pop(deep, stackId);\n      }\n      /**\n       * Returns the URL of the active page of each stack.\n       */\n\n    }, {\n      key: \"getLastUrl\",\n      value: function getLastUrl(stackId) {\n        var active = this.stackCtrl.getLastUrl(stackId);\n        return active ? active.url : undefined;\n      }\n      /**\n       * Returns the RouteView of the active page of each stack.\n       * @internal\n       */\n\n    }, {\n      key: \"getLastRouteView\",\n      value: function getLastRouteView(stackId) {\n        return this.stackCtrl.getLastUrl(stackId);\n      }\n      /**\n       * Returns the root view in the tab stack.\n       * @internal\n       */\n\n    }, {\n      key: \"getRootView\",\n      value: function getRootView(stackId) {\n        return this.stackCtrl.getRootUrl(stackId);\n      }\n      /**\n       * Returns the active stack ID. In the context of ion-tabs, it means the active tab.\n       */\n\n    }, {\n      key: \"getActiveStackId\",\n      value: function getActiveStackId() {\n        return this.stackCtrl.getActiveStackId();\n      }\n      /**\n       * Since the activated route can change over the life time of a component in an ion router outlet, we create\n       * a proxy so that we can update the values over time as a user navigates back to components already in the stack.\n       */\n\n    }, {\n      key: \"createActivatedRouteProxy\",\n      value: function createActivatedRouteProxy(component$, activatedRoute) {\n        var proxy = new ActivatedRoute();\n        proxy._futureSnapshot = activatedRoute._futureSnapshot;\n        proxy._routerState = activatedRoute._routerState;\n        proxy.snapshot = activatedRoute.snapshot;\n        proxy.outlet = activatedRoute.outlet;\n        proxy.component = activatedRoute.component; // Setup wrappers for the observables so consumers don't have to worry about switching to new observables as the state updates\n\n        proxy._paramMap = this.proxyObservable(component$, 'paramMap');\n        proxy._queryParamMap = this.proxyObservable(component$, 'queryParamMap');\n        proxy.url = this.proxyObservable(component$, 'url');\n        proxy.params = this.proxyObservable(component$, 'params');\n        proxy.queryParams = this.proxyObservable(component$, 'queryParams');\n        proxy.fragment = this.proxyObservable(component$, 'fragment');\n        proxy.data = this.proxyObservable(component$, 'data');\n        return proxy;\n      }\n      /**\n       * Create a wrapped observable that will switch to the latest activated route matched by the given component\n       */\n\n    }, {\n      key: \"proxyObservable\",\n      value: function proxyObservable(component$, path) {\n        var _this15 = this;\n\n        return component$.pipe( // First wait until the component instance is pushed\n        filter(function (component) {\n          return !!component;\n        }), switchMap(function (component) {\n          return _this15.currentActivatedRoute$.pipe(filter(function (current) {\n            return current !== null && current.component === component;\n          }), switchMap(function (current) {\n            return current && current.activatedRoute[path];\n          }), distinctUntilChanged());\n        }));\n      }\n      /**\n       * Updates the activated route proxy for the given component to the new incoming router state\n       */\n\n    }, {\n      key: \"updateActivatedRouteProxy\",\n      value: function updateActivatedRouteProxy(component, activatedRoute) {\n        var proxy = this.proxyMap.get(component);\n\n        if (!proxy) {\n          throw new Error(\"Could not find activated route proxy for view\");\n        }\n\n        proxy._futureSnapshot = activatedRoute._futureSnapshot;\n        proxy._routerState = activatedRoute._routerState;\n        proxy.snapshot = activatedRoute.snapshot;\n        proxy.outlet = activatedRoute.outlet;\n        proxy.component = activatedRoute.component;\n        this.currentActivatedRoute$.next({\n          component: component,\n          activatedRoute: activatedRoute\n        });\n      }\n    }]);\n\n    return IonRouterOutlet;\n  }();\n\n  /** @nocollapse */\n  IonRouterOutlet.ɵfac = function IonRouterOutlet_Factory(t) {\n    return new (t || IonRouterOutlet)(i0.ɵɵdirectiveInject(i3.ChildrenOutletContexts), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i0.ComponentFactoryResolver), i0.ɵɵinjectAttribute('name'), i0.ɵɵinjectAttribute('tabs'), i0.ɵɵdirectiveInject(Config), i0.ɵɵdirectiveInject(NavController), i0.ɵɵdirectiveInject(i1.Location), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i3.Router), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i3.ActivatedRoute), i0.ɵɵdirectiveInject(IonRouterOutlet, 12));\n  };\n  /** @nocollapse */\n\n\n  IonRouterOutlet.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IonRouterOutlet,\n    selectors: [[\"ion-router-outlet\"]],\n    inputs: {\n      animated: \"animated\",\n      animation: \"animation\",\n      swipeGesture: \"swipeGesture\"\n    },\n    outputs: {\n      stackEvents: \"stackEvents\",\n      activateEvents: \"activate\",\n      deactivateEvents: \"deactivate\"\n    },\n    exportAs: [\"outlet\"]\n  });\n  return IonRouterOutlet;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar OutletInjector = /*#__PURE__*/function () {\n  function OutletInjector(route, childContexts, parent) {\n    _classCallCheck(this, OutletInjector);\n\n    this.route = route;\n    this.childContexts = childContexts;\n    this.parent = parent;\n  }\n\n  _createClass(OutletInjector, [{\n    key: \"get\",\n    value: function get(token, notFoundValue) {\n      if (token === ActivatedRoute) {\n        return this.route;\n      }\n\n      if (token === ChildrenOutletContexts) {\n        return this.childContexts;\n      }\n\n      return this.parent.get(token, notFoundValue);\n    }\n  }]);\n\n  return OutletInjector;\n}(); // eslint-disable-next-line @angular-eslint/component-class-suffix\n\n\nvar IonTabs = /*#__PURE__*/(function () {\n  var IonTabs = /*#__PURE__*/function () {\n    function IonTabs(navCtrl) {\n      _classCallCheck(this, IonTabs);\n\n      this.navCtrl = navCtrl;\n      this.ionTabsWillChange = new EventEmitter();\n      this.ionTabsDidChange = new EventEmitter();\n    }\n    /**\n     * @internal\n     */\n\n\n    _createClass(IonTabs, [{\n      key: \"onPageSelected\",\n      value: function onPageSelected(detail) {\n        var stackId = detail.enteringView.stackId;\n\n        if (detail.tabSwitch && stackId !== undefined) {\n          this.ionTabsWillChange.emit({\n            tab: stackId\n          });\n\n          if (this.tabBar) {\n            this.tabBar.selectedTab = stackId;\n          }\n\n          this.ionTabsDidChange.emit({\n            tab: stackId\n          });\n        }\n      }\n      /**\n       * When a tab button is clicked, there are several scenarios:\n       * 1. If the selected tab is currently active (the tab button has been clicked\n       *    again), then it should go to the root view for that tab.\n       *\n       *   a. Get the saved root view from the router outlet. If the saved root view\n       *      matches the tabRootUrl, set the route view to this view including the\n       *      navigation extras.\n       *   b. If the saved root view from the router outlet does\n       *      not match, navigate to the tabRootUrl. No navigation extras are\n       *      included.\n       *\n       * 2. If the current tab tab is not currently selected, get the last route\n       *    view from the router outlet.\n       *\n       *   a. If the last route view exists, navigate to that view including any\n       *      navigation extras\n       *   b. If the last route view doesn't exist, then navigate\n       *      to the default tabRootUrl\n       */\n\n    }, {\n      key: \"select\",\n      value: function select(tabOrEvent) {\n        var isTabString = typeof tabOrEvent === 'string';\n        var tab = isTabString ? tabOrEvent : tabOrEvent.detail.tab;\n        var alreadySelected = this.outlet.getActiveStackId() === tab;\n        var tabRootUrl = \"\".concat(this.outlet.tabsPrefix, \"/\").concat(tab);\n        /**\n         * If this is a nested tab, prevent the event\n         * from bubbling otherwise the outer tabs\n         * will respond to this event too, causing\n         * the app to get directed to the wrong place.\n         */\n\n        if (!isTabString) {\n          tabOrEvent.stopPropagation();\n        }\n\n        if (alreadySelected) {\n          var activeStackId = this.outlet.getActiveStackId();\n          var activeView = this.outlet.getLastRouteView(activeStackId); // If on root tab, do not navigate to root tab again\n\n          if ((activeView === null || activeView === void 0 ? void 0 : activeView.url) === tabRootUrl) {\n            return;\n          }\n\n          var rootView = this.outlet.getRootView(tab);\n          var navigationExtras = rootView && tabRootUrl === rootView.url && rootView.savedExtras;\n          return this.navCtrl.navigateRoot(tabRootUrl, Object.assign(Object.assign({}, navigationExtras), {\n            animated: true,\n            animationDirection: 'back'\n          }));\n        } else {\n          var lastRoute = this.outlet.getLastRouteView(tab);\n          /**\n           * If there is a lastRoute, goto that, otherwise goto the fallback url of the\n           * selected tab\n           */\n\n          var url = (lastRoute === null || lastRoute === void 0 ? void 0 : lastRoute.url) || tabRootUrl;\n\n          var _navigationExtras = lastRoute === null || lastRoute === void 0 ? void 0 : lastRoute.savedExtras;\n\n          return this.navCtrl.navigateRoot(url, Object.assign(Object.assign({}, _navigationExtras), {\n            animated: true,\n            animationDirection: 'back'\n          }));\n        }\n      }\n    }, {\n      key: \"getSelected\",\n      value: function getSelected() {\n        return this.outlet.getActiveStackId();\n      }\n    }]);\n\n    return IonTabs;\n  }();\n\n  /** @nocollapse */\n  IonTabs.ɵfac = function IonTabs_Factory(t) {\n    return new (t || IonTabs)(i0.ɵɵdirectiveInject(NavController));\n  };\n  /** @nocollapse */\n\n\n  IonTabs.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonTabs,\n    selectors: [[\"ion-tabs\"]],\n    contentQueries: function IonTabs_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, IonTabBar, 5);\n      }\n\n      if (rf & 2) {\n        var _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tabBar = _t.first);\n      }\n    },\n    viewQuery: function IonTabs_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c1, 5, IonRouterOutlet);\n      }\n\n      if (rf & 2) {\n        var _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.outlet = _t.first);\n      }\n    },\n    hostBindings: function IonTabs_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"ionTabButtonClick\", function IonTabs_ionTabButtonClick_HostBindingHandler($event) {\n          return ctx.select($event);\n        });\n      }\n    },\n    outputs: {\n      ionTabsWillChange: \"ionTabsWillChange\",\n      ionTabsDidChange: \"ionTabsDidChange\"\n    },\n    ngContentSelectors: _c3,\n    decls: 5,\n    vars: 0,\n    consts: [[1, \"tabs-inner\"], [\"tabs\", \"true\", 3, \"stackEvents\"], [\"outlet\", \"\"]],\n    template: function IonTabs_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c2);\n        i0.ɵɵprojection(0);\n        i0.ɵɵelementStart(1, \"div\", 0)(2, \"ion-router-outlet\", 1, 2);\n        i0.ɵɵlistener(\"stackEvents\", function IonTabs_Template_ion_router_outlet_stackEvents_2_listener($event) {\n          return ctx.onPageSelected($event);\n        });\n        i0.ɵɵelementEnd()();\n        i0.ɵɵprojection(4, 1);\n      }\n    },\n    directives: [IonRouterOutlet],\n    styles: [\"[_nghost-%COMP%] {\\n        display: flex;\\n        position: absolute;\\n        top: 0;\\n        left: 0;\\n        right: 0;\\n        bottom: 0;\\n\\n        flex-direction: column;\\n\\n        width: 100%;\\n        height: 100%;\\n\\n        contain: layout size style;\\n        z-index: $z-index-page-container;\\n      }\\n      .tabs-inner[_ngcontent-%COMP%] {\\n        position: relative;\\n\\n        flex: 1;\\n\\n        contain: layout size style;\\n      }\"]\n  });\n  return IonTabs;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonBackButtonDelegateDirective = /*#__PURE__*/(function () {\n  var IonBackButtonDelegateDirective = /*#__PURE__*/function () {\n    function IonBackButtonDelegateDirective(routerOutlet, navCtrl, config) {\n      _classCallCheck(this, IonBackButtonDelegateDirective);\n\n      this.routerOutlet = routerOutlet;\n      this.navCtrl = navCtrl;\n      this.config = config;\n    }\n    /**\n     * @internal\n     */\n\n\n    _createClass(IonBackButtonDelegateDirective, [{\n      key: \"onClick\",\n      value: function onClick(ev) {\n        var _a;\n\n        var defaultHref = this.defaultHref || this.config.get('backButtonDefaultHref');\n\n        if ((_a = this.routerOutlet) === null || _a === void 0 ? void 0 : _a.canGoBack()) {\n          this.navCtrl.setDirection('back', undefined, undefined, this.routerAnimation);\n          this.routerOutlet.pop();\n          ev.preventDefault();\n        } else if (defaultHref != null) {\n          this.navCtrl.navigateBack(defaultHref, {\n            animation: this.routerAnimation\n          });\n          ev.preventDefault();\n        }\n      }\n    }]);\n\n    return IonBackButtonDelegateDirective;\n  }();\n\n  /** @nocollapse */\n  IonBackButtonDelegateDirective.ɵfac = function IonBackButtonDelegateDirective_Factory(t) {\n    return new (t || IonBackButtonDelegateDirective)(i0.ɵɵdirectiveInject(IonRouterOutlet, 8), i0.ɵɵdirectiveInject(NavController), i0.ɵɵdirectiveInject(Config));\n  };\n  /** @nocollapse */\n\n\n  IonBackButtonDelegateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IonBackButtonDelegateDirective,\n    selectors: [[\"ion-back-button\"]],\n    hostBindings: function IonBackButtonDelegateDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function IonBackButtonDelegateDirective_click_HostBindingHandler($event) {\n          return ctx.onClick($event);\n        });\n      }\n    },\n    inputs: {\n      defaultHref: \"defaultHref\",\n      routerAnimation: \"routerAnimation\"\n    }\n  });\n  return IonBackButtonDelegateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar NavDelegate = /*#__PURE__*/(function () {\n  var NavDelegate = /*#__PURE__*/_createClass(function NavDelegate(ref, resolver, injector, angularDelegate, location) {\n    _classCallCheck(this, NavDelegate);\n\n    this.el = ref.nativeElement;\n    ref.nativeElement.delegate = angularDelegate.create(resolver, injector, location);\n    proxyOutputs(this, this.el, ['ionNavDidChange', 'ionNavWillChange']);\n  });\n\n  /** @nocollapse */\n  NavDelegate.ɵfac = function NavDelegate_Factory(t) {\n    return new (t || NavDelegate)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ComponentFactoryResolver), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(AngularDelegate), i0.ɵɵdirectiveInject(i0.ViewContainerRef));\n  };\n  /** @nocollapse */\n\n\n  NavDelegate.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NavDelegate,\n    selectors: [[\"ion-nav\"]]\n  });\n  NavDelegate = __decorate([ProxyCmp({\n    inputs: ['animated', 'animation', 'root', 'rootParams', 'swipeGesture'],\n    methods: ['push', 'insert', 'insertPages', 'pop', 'popTo', 'popToRoot', 'removeIndex', 'setRoot', 'setPages', 'getActive', 'getByIndex', 'canGoBack', 'getPrevious']\n  })], NavDelegate);\n  return NavDelegate;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Adds support for Ionic routing directions and animations to the base Angular router link directive.\n *\n * When the router link is clicked, the directive will assign the direction and\n * animation so that the routing integration will transition correctly.\n */\n\n\nvar RouterLinkDelegateDirective = /*#__PURE__*/(function () {\n  var RouterLinkDelegateDirective = /*#__PURE__*/function () {\n    function RouterLinkDelegateDirective(locationStrategy, navCtrl, elementRef, router, routerLink) {\n      _classCallCheck(this, RouterLinkDelegateDirective);\n\n      this.locationStrategy = locationStrategy;\n      this.navCtrl = navCtrl;\n      this.elementRef = elementRef;\n      this.router = router;\n      this.routerLink = routerLink;\n      this.routerDirection = 'forward';\n    }\n\n    _createClass(RouterLinkDelegateDirective, [{\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        this.updateTargetUrlAndHref();\n      }\n    }, {\n      key: \"ngOnChanges\",\n      value: function ngOnChanges() {\n        this.updateTargetUrlAndHref();\n      }\n    }, {\n      key: \"updateTargetUrlAndHref\",\n      value: function updateTargetUrlAndHref() {\n        var _a;\n\n        if ((_a = this.routerLink) === null || _a === void 0 ? void 0 : _a.urlTree) {\n          var href = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.routerLink.urlTree));\n          this.elementRef.nativeElement.href = href;\n        }\n      }\n      /**\n       * @internal\n       */\n\n    }, {\n      key: \"onClick\",\n      value: function onClick(ev) {\n        this.navCtrl.setDirection(this.routerDirection, undefined, undefined, this.routerAnimation);\n        /**\n         * This prevents the browser from\n         * performing a page reload when pressing\n         * an Ionic component with routerLink.\n         * The page reload interferes with routing\n         * and causes ion-back-button to disappear\n         * since the local history is wiped on reload.\n         */\n\n        ev.preventDefault();\n      }\n    }]);\n\n    return RouterLinkDelegateDirective;\n  }();\n\n  /** @nocollapse */\n  RouterLinkDelegateDirective.ɵfac = function RouterLinkDelegateDirective_Factory(t) {\n    return new (t || RouterLinkDelegateDirective)(i0.ɵɵdirectiveInject(i1.LocationStrategy), i0.ɵɵdirectiveInject(NavController), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i3.Router), i0.ɵɵdirectiveInject(i3.RouterLink, 8));\n  };\n  /** @nocollapse */\n\n\n  RouterLinkDelegateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: RouterLinkDelegateDirective,\n    selectors: [[\"\", \"routerLink\", \"\", 5, \"a\", 5, \"area\"]],\n    hostBindings: function RouterLinkDelegateDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function RouterLinkDelegateDirective_click_HostBindingHandler($event) {\n          return ctx.onClick($event);\n        });\n      }\n    },\n    inputs: {\n      routerDirection: \"routerDirection\",\n      routerAnimation: \"routerAnimation\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return RouterLinkDelegateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar RouterLinkWithHrefDelegateDirective = /*#__PURE__*/(function () {\n  var RouterLinkWithHrefDelegateDirective = /*#__PURE__*/function () {\n    function RouterLinkWithHrefDelegateDirective(locationStrategy, navCtrl, elementRef, router, routerLink) {\n      _classCallCheck(this, RouterLinkWithHrefDelegateDirective);\n\n      this.locationStrategy = locationStrategy;\n      this.navCtrl = navCtrl;\n      this.elementRef = elementRef;\n      this.router = router;\n      this.routerLink = routerLink;\n      this.routerDirection = 'forward';\n    }\n\n    _createClass(RouterLinkWithHrefDelegateDirective, [{\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        this.updateTargetUrlAndHref();\n      }\n    }, {\n      key: \"ngOnChanges\",\n      value: function ngOnChanges() {\n        this.updateTargetUrlAndHref();\n      }\n    }, {\n      key: \"updateTargetUrlAndHref\",\n      value: function updateTargetUrlAndHref() {\n        var _a;\n\n        if ((_a = this.routerLink) === null || _a === void 0 ? void 0 : _a.urlTree) {\n          var href = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.routerLink.urlTree));\n          this.elementRef.nativeElement.href = href;\n        }\n      }\n      /**\n       * @internal\n       */\n\n    }, {\n      key: \"onClick\",\n      value: function onClick() {\n        this.navCtrl.setDirection(this.routerDirection, undefined, undefined, this.routerAnimation);\n      }\n    }]);\n\n    return RouterLinkWithHrefDelegateDirective;\n  }();\n\n  /** @nocollapse */\n  RouterLinkWithHrefDelegateDirective.ɵfac = function RouterLinkWithHrefDelegateDirective_Factory(t) {\n    return new (t || RouterLinkWithHrefDelegateDirective)(i0.ɵɵdirectiveInject(i1.LocationStrategy), i0.ɵɵdirectiveInject(NavController), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i3.Router), i0.ɵɵdirectiveInject(i3.RouterLink, 8));\n  };\n  /** @nocollapse */\n\n\n  RouterLinkWithHrefDelegateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: RouterLinkWithHrefDelegateDirective,\n    selectors: [[\"a\", \"routerLink\", \"\"], [\"area\", \"routerLink\", \"\"]],\n    hostBindings: function RouterLinkWithHrefDelegateDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function RouterLinkWithHrefDelegateDirective_click_HostBindingHandler() {\n          return ctx.onClick();\n        });\n      }\n    },\n    inputs: {\n      routerDirection: \"routerDirection\",\n      routerAnimation: \"routerAnimation\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return RouterLinkWithHrefDelegateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nvar VirtualFooter = /*#__PURE__*/(function () {\n  var VirtualFooter = /*#__PURE__*/_createClass(function VirtualFooter(templateRef) {\n    _classCallCheck(this, VirtualFooter);\n\n    this.templateRef = templateRef;\n  });\n\n  /** @nocollapse */\n  VirtualFooter.ɵfac = function VirtualFooter_Factory(t) {\n    return new (t || VirtualFooter)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n  /** @nocollapse */\n\n\n  VirtualFooter.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: VirtualFooter,\n    selectors: [[\"\", \"virtualFooter\", \"\"]]\n  });\n  return VirtualFooter;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nvar VirtualHeader = /*#__PURE__*/(function () {\n  var VirtualHeader = /*#__PURE__*/_createClass(function VirtualHeader(templateRef) {\n    _classCallCheck(this, VirtualHeader);\n\n    this.templateRef = templateRef;\n  });\n\n  /** @nocollapse */\n  VirtualHeader.ɵfac = function VirtualHeader_Factory(t) {\n    return new (t || VirtualHeader)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n  /** @nocollapse */\n\n\n  VirtualHeader.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: VirtualHeader,\n    selectors: [[\"\", \"virtualHeader\", \"\"]]\n  });\n  return VirtualHeader;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nvar VirtualItem = /*#__PURE__*/(function () {\n  var VirtualItem = /*#__PURE__*/_createClass(function VirtualItem(templateRef, viewContainer) {\n    _classCallCheck(this, VirtualItem);\n\n    this.templateRef = templateRef;\n    this.viewContainer = viewContainer;\n  });\n\n  /** @nocollapse */\n  VirtualItem.ɵfac = function VirtualItem_Factory(t) {\n    return new (t || VirtualItem)(i0.ɵɵdirectiveInject(i0.TemplateRef), i0.ɵɵdirectiveInject(i0.ViewContainerRef));\n  };\n  /** @nocollapse */\n\n\n  VirtualItem.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: VirtualItem,\n    selectors: [[\"\", \"virtualItem\", \"\"]]\n  });\n  return VirtualItem;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonVirtualScroll = /*#__PURE__*/(function () {\n  var IonVirtualScroll = /*#__PURE__*/function () {\n    function IonVirtualScroll(z, iterableDiffers, elementRef) {\n      _classCallCheck(this, IonVirtualScroll);\n\n      this.z = z;\n      this.iterableDiffers = iterableDiffers;\n      this.refMap = new WeakMap();\n      this.el = elementRef.nativeElement;\n      this.el.nodeRender = this.nodeRender.bind(this);\n    }\n\n    _createClass(IonVirtualScroll, [{\n      key: \"ngOnChanges\",\n      value: function ngOnChanges(changes) {\n        if (this.trackBy && 'items' in changes) {\n          // React on virtualScroll changes only once all inputs have been initialized\n          var value = changes['items'].currentValue;\n\n          if (this.differ === undefined && value != null) {\n            try {\n              this.differ = this.iterableDiffers.find(value).create(this.trackBy);\n            } catch (e) {\n              throw new Error(\"Cannot find a differ supporting object '\".concat(value, \"'. VirtualScroll only supports binding to Iterables such as Arrays.\"));\n            }\n          }\n        }\n      }\n    }, {\n      key: \"ngDoCheck\",\n      value: function ngDoCheck() {\n        // and if there actually are changes\n        var changes = this.differ !== undefined && this.items ? this.differ.diff(this.items) : null;\n\n        if (changes === null) {\n          return;\n        } // TODO: optimize\n\n\n        this.checkRange(0);\n      }\n    }, {\n      key: \"nodeRender\",\n      value: function nodeRender(el, cell, index) {\n        var _this16 = this;\n\n        return this.z.run(function () {\n          var node;\n\n          if (!el) {\n            node = _this16.itmTmp.viewContainer.createEmbeddedView(_this16.getComponent(cell.type), {\n              $implicit: cell.value,\n              index: index\n            }, index);\n            el = getElement(node);\n\n            _this16.refMap.set(el, node);\n          } else {\n            node = _this16.refMap.get(el);\n            var ctx = node.context;\n            ctx.$implicit = cell.value;\n            ctx.index = cell.index;\n          } // run sync change detections\n\n\n          node.detectChanges();\n          return el;\n        });\n      }\n    }, {\n      key: \"getComponent\",\n      value: function getComponent(type) {\n        switch (type) {\n          case 'item':\n            return this.itmTmp.templateRef;\n\n          case 'header':\n            return this.hdrTmp.templateRef;\n\n          case 'footer':\n            return this.ftrTmp.templateRef;\n\n          default:\n            throw new Error('template for virtual item was not provided');\n        }\n      }\n    }]);\n\n    return IonVirtualScroll;\n  }();\n\n  /** @nocollapse */\n  IonVirtualScroll.ɵfac = function IonVirtualScroll_Factory(t) {\n    return new (t || IonVirtualScroll)(i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.IterableDiffers), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n  /** @nocollapse */\n\n\n  IonVirtualScroll.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonVirtualScroll,\n    selectors: [[\"ion-virtual-scroll\"]],\n    contentQueries: function IonVirtualScroll_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, VirtualItem, 5);\n        i0.ɵɵcontentQuery(dirIndex, VirtualHeader, 5);\n        i0.ɵɵcontentQuery(dirIndex, VirtualFooter, 5);\n      }\n\n      if (rf & 2) {\n        var _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.itmTmp = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.hdrTmp = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.ftrTmp = _t.first);\n      }\n    },\n    inputs: {\n      approxItemHeight: \"approxItemHeight\",\n      approxHeaderHeight: \"approxHeaderHeight\",\n      approxFooterHeight: \"approxFooterHeight\",\n      headerFn: \"headerFn\",\n      footerFn: \"footerFn\",\n      items: \"items\",\n      itemHeight: \"itemHeight\",\n      headerHeight: \"headerHeight\",\n      footerHeight: \"footerHeight\",\n      trackBy: \"trackBy\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonVirtualScroll_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonVirtualScroll = __decorate([ProxyCmp({\n    inputs: ['approxItemHeight', 'approxHeaderHeight', 'approxFooterHeight', 'headerFn', 'footerFn', 'items', 'itemHeight', 'headerHeight', 'footerHeight'],\n    methods: ['checkEnd', 'checkRange', 'positionForItem']\n  })], IonVirtualScroll);\n  return IonVirtualScroll;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar getElement = function getElement(view) {\n  var rootNodes = view.rootNodes;\n\n  for (var i = 0; i < rootNodes.length; i++) {\n    if (rootNodes[i].nodeType === 1) {\n      return rootNodes[i];\n    }\n  }\n\n  throw new Error('virtual element was not created');\n};\n\nvar IonModal = /*#__PURE__*/(function () {\n  var IonModal = /*#__PURE__*/_createClass(function IonModal(c, r, z) {\n    var _this17 = this;\n\n    _classCallCheck(this, IonModal);\n\n    this.z = z;\n    this.isCmpOpen = false;\n    this.el = r.nativeElement;\n    this.el.addEventListener('willPresent', function () {\n      _this17.isCmpOpen = true;\n      c.detectChanges();\n    });\n    this.el.addEventListener('didDismiss', function () {\n      _this17.isCmpOpen = false;\n      c.detectChanges();\n    });\n    proxyOutputs(this, this.el, ['ionModalDidPresent', 'ionModalWillPresent', 'ionModalWillDismiss', 'ionModalDidDismiss', 'ionBreakpointDidChange', 'didPresent', 'willPresent', 'willDismiss', 'didDismiss']);\n  });\n\n  /** @nocollapse */\n  IonModal.ɵfac = function IonModal_Factory(t) {\n    return new (t || IonModal)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonModal.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonModal,\n    selectors: [[\"ion-modal\"]],\n    contentQueries: function IonModal_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, TemplateRef, 5);\n      }\n\n      if (rf & 2) {\n        var _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.template = _t.first);\n      }\n    },\n    inputs: {\n      animated: \"animated\",\n      backdropBreakpoint: \"backdropBreakpoint\",\n      backdropDismiss: \"backdropDismiss\",\n      breakpoints: \"breakpoints\",\n      canDismiss: \"canDismiss\",\n      cssClass: \"cssClass\",\n      enterAnimation: \"enterAnimation\",\n      event: \"event\",\n      handle: \"handle\",\n      initialBreakpoint: \"initialBreakpoint\",\n      isOpen: \"isOpen\",\n      keyboardClose: \"keyboardClose\",\n      leaveAnimation: \"leaveAnimation\",\n      mode: \"mode\",\n      presentingElement: \"presentingElement\",\n      showBackdrop: \"showBackdrop\",\n      swipeToClose: \"swipeToClose\",\n      translucent: \"translucent\",\n      trigger: \"trigger\"\n    },\n    decls: 1,\n    vars: 1,\n    consts: [[\"class\", \"ion-page\", 4, \"ngIf\"], [1, \"ion-page\"], [3, \"ngTemplateOutlet\"]],\n    template: function IonModal_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, IonModal_div_0_Template, 2, 1, \"div\", 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.isCmpOpen);\n      }\n    },\n    directives: [i1.NgIf, i1.NgTemplateOutlet],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonModal = __decorate([ProxyCmp({\n    inputs: ['animated', 'backdropBreakpoint', 'backdropDismiss', 'breakpoints', 'canDismiss', 'cssClass', 'enterAnimation', 'event', 'handle', 'initialBreakpoint', 'isOpen', 'keyboardClose', 'leaveAnimation', 'mode', 'presentingElement', 'showBackdrop', 'swipeToClose', 'translucent', 'trigger'],\n    methods: ['present', 'dismiss', 'onDidDismiss', 'onWillDismiss', 'setCurrentBreakpoint', 'getCurrentBreakpoint']\n  })], IonModal);\n  return IonModal;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonPopover = /*#__PURE__*/(function () {\n  var IonPopover = /*#__PURE__*/_createClass(function IonPopover(c, r, z) {\n    var _this18 = this;\n\n    _classCallCheck(this, IonPopover);\n\n    this.z = z;\n    this.isCmpOpen = false;\n    this.el = r.nativeElement;\n    this.el.addEventListener('willPresent', function () {\n      _this18.isCmpOpen = true;\n      c.detectChanges();\n    });\n    this.el.addEventListener('didDismiss', function () {\n      _this18.isCmpOpen = false;\n      c.detectChanges();\n    });\n    proxyOutputs(this, this.el, ['ionPopoverDidPresent', 'ionPopoverWillPresent', 'ionPopoverWillDismiss', 'ionPopoverDidDismiss', 'didPresent', 'willPresent', 'willDismiss', 'didDismiss']);\n  });\n\n  /** @nocollapse */\n  IonPopover.ɵfac = function IonPopover_Factory(t) {\n    return new (t || IonPopover)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  IonPopover.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IonPopover,\n    selectors: [[\"ion-popover\"]],\n    contentQueries: function IonPopover_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, TemplateRef, 5);\n      }\n\n      if (rf & 2) {\n        var _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.template = _t.first);\n      }\n    },\n    inputs: {\n      alignment: \"alignment\",\n      animated: \"animated\",\n      arrow: \"arrow\",\n      backdropDismiss: \"backdropDismiss\",\n      cssClass: \"cssClass\",\n      dismissOnSelect: \"dismissOnSelect\",\n      enterAnimation: \"enterAnimation\",\n      event: \"event\",\n      isOpen: \"isOpen\",\n      keyboardClose: \"keyboardClose\",\n      leaveAnimation: \"leaveAnimation\",\n      mode: \"mode\",\n      showBackdrop: \"showBackdrop\",\n      translucent: \"translucent\",\n      trigger: \"trigger\",\n      triggerAction: \"triggerAction\",\n      reference: \"reference\",\n      size: \"size\",\n      side: \"side\"\n    },\n    decls: 1,\n    vars: 1,\n    consts: [[3, \"ngTemplateOutlet\", 4, \"ngIf\"], [3, \"ngTemplateOutlet\"]],\n    template: function IonPopover_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, IonPopover_ng_container_0_Template, 1, 1, \"ng-container\", 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.isCmpOpen);\n      }\n    },\n    directives: [i1.NgIf, i1.NgTemplateOutlet],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonPopover = __decorate([ProxyCmp({\n    inputs: ['alignment', 'animated', 'arrow', 'backdropDismiss', 'cssClass', 'dismissOnSelect', 'enterAnimation', 'event', 'isOpen', 'keyboardClose', 'leaveAnimation', 'mode', 'showBackdrop', 'translucent', 'trigger', 'triggerAction', 'reference', 'size', 'side'],\n    methods: ['present', 'dismiss', 'onDidDismiss', 'onWillDismiss']\n  })], IonPopover);\n  return IonPopover;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar OverlayBaseController = /*#__PURE__*/function () {\n  function OverlayBaseController(ctrl) {\n    _classCallCheck(this, OverlayBaseController);\n\n    this.ctrl = ctrl;\n  }\n  /**\n   * Creates a new overlay\n   */\n\n\n  _createClass(OverlayBaseController, [{\n    key: \"create\",\n    value: function create(opts) {\n      // TODO: next major release opts is not optional\n      return this.ctrl.create(opts || {});\n    }\n    /**\n     * When `id` is not provided, it dismisses the top overlay.\n     */\n\n  }, {\n    key: \"dismiss\",\n    value: function dismiss(data, role, id) {\n      return this.ctrl.dismiss(data, role, id);\n    }\n    /**\n     * Returns the top overlay.\n     */\n\n  }, {\n    key: \"getTop\",\n    value: function getTop() {\n      return this.ctrl.getTop();\n    }\n  }]);\n\n  return OverlayBaseController;\n}();\n\nvar ActionSheetController = /*#__PURE__*/(function () {\n  var ActionSheetController = /*#__PURE__*/function (_OverlayBaseControlle) {\n    _inherits(ActionSheetController, _OverlayBaseControlle);\n\n    var _super6 = _createSuper(ActionSheetController);\n\n    function ActionSheetController() {\n      _classCallCheck(this, ActionSheetController);\n\n      return _super6.call(this, actionSheetController);\n    }\n\n    return _createClass(ActionSheetController);\n  }(OverlayBaseController);\n\n  /** @nocollapse */\n  ActionSheetController.ɵfac = function ActionSheetController_Factory(t) {\n    return new (t || ActionSheetController)();\n  };\n  /** @nocollapse */\n\n\n  ActionSheetController.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ActionSheetController,\n    factory: ActionSheetController.ɵfac,\n    providedIn: 'root'\n  });\n  return ActionSheetController;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar AlertController = /*#__PURE__*/(function () {\n  var AlertController = /*#__PURE__*/function (_OverlayBaseControlle2) {\n    _inherits(AlertController, _OverlayBaseControlle2);\n\n    var _super7 = _createSuper(AlertController);\n\n    function AlertController() {\n      _classCallCheck(this, AlertController);\n\n      return _super7.call(this, alertController);\n    }\n\n    return _createClass(AlertController);\n  }(OverlayBaseController);\n\n  /** @nocollapse */\n  AlertController.ɵfac = function AlertController_Factory(t) {\n    return new (t || AlertController)();\n  };\n  /** @nocollapse */\n\n\n  AlertController.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AlertController,\n    factory: AlertController.ɵfac,\n    providedIn: 'root'\n  });\n  return AlertController;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar LoadingController = /*#__PURE__*/(function () {\n  var LoadingController = /*#__PURE__*/function (_OverlayBaseControlle3) {\n    _inherits(LoadingController, _OverlayBaseControlle3);\n\n    var _super8 = _createSuper(LoadingController);\n\n    function LoadingController() {\n      _classCallCheck(this, LoadingController);\n\n      return _super8.call(this, loadingController);\n    }\n\n    return _createClass(LoadingController);\n  }(OverlayBaseController);\n\n  /** @nocollapse */\n  LoadingController.ɵfac = function LoadingController_Factory(t) {\n    return new (t || LoadingController)();\n  };\n  /** @nocollapse */\n\n\n  LoadingController.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: LoadingController,\n    factory: LoadingController.ɵfac,\n    providedIn: 'root'\n  });\n  return LoadingController;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar MenuController = /*#__PURE__*/(function () {\n  var MenuController = /*#__PURE__*/function () {\n    function MenuController() {\n      _classCallCheck(this, MenuController);\n    }\n\n    _createClass(MenuController, [{\n      key: \"open\",\n      value:\n      /**\n       * Programmatically open the Menu.\n       * @param [menuId]  Optionally get the menu by its id, or side.\n       * @return returns a promise when the menu is fully opened\n       */\n      function open(menuId) {\n        return menuController.open(menuId);\n      }\n      /**\n       * Programmatically close the Menu. If no `menuId` is given as the first\n       * argument then it'll close any menu which is open. If a `menuId`\n       * is given then it'll close that exact menu.\n       * @param [menuId]  Optionally get the menu by its id, or side.\n       * @return returns a promise when the menu is fully closed\n       */\n\n    }, {\n      key: \"close\",\n      value: function close(menuId) {\n        return menuController.close(menuId);\n      }\n      /**\n       * Toggle the menu. If it's closed, it will open, and if opened, it\n       * will close.\n       * @param [menuId]  Optionally get the menu by its id, or side.\n       * @return returns a promise when the menu has been toggled\n       */\n\n    }, {\n      key: \"toggle\",\n      value: function toggle(menuId) {\n        return menuController.toggle(menuId);\n      }\n      /**\n       * Used to enable or disable a menu. For example, there could be multiple\n       * left menus, but only one of them should be able to be opened at the same\n       * time. If there are multiple menus on the same side, then enabling one menu\n       * will also automatically disable all the others that are on the same side.\n       * @param [menuId]  Optionally get the menu by its id, or side.\n       * @return Returns the instance of the menu, which is useful for chaining.\n       */\n\n    }, {\n      key: \"enable\",\n      value: function enable(shouldEnable, menuId) {\n        return menuController.enable(shouldEnable, menuId);\n      }\n      /**\n       * Used to enable or disable the ability to swipe open the menu.\n       * @param shouldEnable  True if it should be swipe-able, false if not.\n       * @param [menuId]  Optionally get the menu by its id, or side.\n       * @return Returns the instance of the menu, which is useful for chaining.\n       */\n\n    }, {\n      key: \"swipeGesture\",\n      value: function swipeGesture(shouldEnable, menuId) {\n        return menuController.swipeGesture(shouldEnable, menuId);\n      }\n      /**\n       * @param [menuId] Optionally get the menu by its id, or side.\n       * @return Returns true if the specified menu is currently open, otherwise false.\n       * If the menuId is not specified, it returns true if ANY menu is currenly open.\n       */\n\n    }, {\n      key: \"isOpen\",\n      value: function isOpen(menuId) {\n        return menuController.isOpen(menuId);\n      }\n      /**\n       * @param [menuId]  Optionally get the menu by its id, or side.\n       * @return Returns true if the menu is currently enabled, otherwise false.\n       */\n\n    }, {\n      key: \"isEnabled\",\n      value: function isEnabled(menuId) {\n        return menuController.isEnabled(menuId);\n      }\n      /**\n       * Used to get a menu instance. If a `menuId` is not provided then it'll\n       * return the first menu found. If a `menuId` is `left` or `right`, then\n       * it'll return the enabled menu on that side. Otherwise, if a `menuId` is\n       * provided, then it'll try to find the menu using the menu's `id`\n       * property. If a menu is not found then it'll return `null`.\n       * @param [menuId]  Optionally get the menu by its id, or side.\n       * @return Returns the instance of the menu if found, otherwise `null`.\n       */\n\n    }, {\n      key: \"get\",\n      value: function get(menuId) {\n        return menuController.get(menuId);\n      }\n      /**\n       * @return Returns the instance of the menu already opened, otherwise `null`.\n       */\n\n    }, {\n      key: \"getOpen\",\n      value: function getOpen() {\n        return menuController.getOpen();\n      }\n      /**\n       * @return Returns an array of all menu instances.\n       */\n\n    }, {\n      key: \"getMenus\",\n      value: function getMenus() {\n        return menuController.getMenus();\n      }\n    }]);\n\n    return MenuController;\n  }();\n\n  /** @nocollapse */\n  MenuController.ɵfac = function MenuController_Factory(t) {\n    return new (t || MenuController)();\n  };\n  /** @nocollapse */\n\n\n  MenuController.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: MenuController,\n    factory: MenuController.ɵfac,\n    providedIn: 'root'\n  });\n  return MenuController;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar PickerController = /*#__PURE__*/(function () {\n  var PickerController = /*#__PURE__*/function (_OverlayBaseControlle4) {\n    _inherits(PickerController, _OverlayBaseControlle4);\n\n    var _super9 = _createSuper(PickerController);\n\n    function PickerController() {\n      _classCallCheck(this, PickerController);\n\n      return _super9.call(this, pickerController);\n    }\n\n    return _createClass(PickerController);\n  }(OverlayBaseController);\n\n  /** @nocollapse */\n  PickerController.ɵfac = function PickerController_Factory(t) {\n    return new (t || PickerController)();\n  };\n  /** @nocollapse */\n\n\n  PickerController.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: PickerController,\n    factory: PickerController.ɵfac,\n    providedIn: 'root'\n  });\n  return PickerController;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar ModalController = /*#__PURE__*/(function () {\n  var ModalController = /*#__PURE__*/function (_OverlayBaseControlle5) {\n    _inherits(ModalController, _OverlayBaseControlle5);\n\n    var _super10 = _createSuper(ModalController);\n\n    function ModalController(angularDelegate, resolver, injector) {\n      var _this19;\n\n      _classCallCheck(this, ModalController);\n\n      _this19 = _super10.call(this, modalController);\n      _this19.angularDelegate = angularDelegate;\n      _this19.resolver = resolver;\n      _this19.injector = injector;\n      return _this19;\n    }\n\n    _createClass(ModalController, [{\n      key: \"create\",\n      value: function create(opts) {\n        return _get(_getPrototypeOf(ModalController.prototype), \"create\", this).call(this, Object.assign(Object.assign({}, opts), {\n          delegate: this.angularDelegate.create(this.resolver, this.injector)\n        }));\n      }\n    }]);\n\n    return ModalController;\n  }(OverlayBaseController);\n\n  /** @nocollapse */\n  ModalController.ɵfac = function ModalController_Factory(t) {\n    return new (t || ModalController)(i0.ɵɵinject(AngularDelegate), i0.ɵɵinject(i0.ComponentFactoryResolver), i0.ɵɵinject(i0.Injector));\n  };\n  /** @nocollapse */\n\n\n  ModalController.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ModalController,\n    factory: ModalController.ɵfac\n  });\n  return ModalController;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar PopoverController = /*#__PURE__*/(function () {\n  var PopoverController = /*#__PURE__*/function (_OverlayBaseControlle6) {\n    _inherits(PopoverController, _OverlayBaseControlle6);\n\n    var _super11 = _createSuper(PopoverController);\n\n    function PopoverController(angularDelegate, resolver, injector) {\n      var _this20;\n\n      _classCallCheck(this, PopoverController);\n\n      _this20 = _super11.call(this, popoverController);\n      _this20.angularDelegate = angularDelegate;\n      _this20.resolver = resolver;\n      _this20.injector = injector;\n      return _this20;\n    }\n\n    _createClass(PopoverController, [{\n      key: \"create\",\n      value: function create(opts) {\n        return _get(_getPrototypeOf(PopoverController.prototype), \"create\", this).call(this, Object.assign(Object.assign({}, opts), {\n          delegate: this.angularDelegate.create(this.resolver, this.injector)\n        }));\n      }\n    }]);\n\n    return PopoverController;\n  }(OverlayBaseController);\n\n  /** @nocollapse */\n  PopoverController.ɵfac = function PopoverController_Factory(t) {\n    return new (t || PopoverController)(i0.ɵɵinject(AngularDelegate), i0.ɵɵinject(i0.ComponentFactoryResolver), i0.ɵɵinject(i0.Injector));\n  };\n  /** @nocollapse */\n\n\n  PopoverController.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: PopoverController,\n    factory: PopoverController.ɵfac\n  });\n  return PopoverController;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar ToastController = /*#__PURE__*/(function () {\n  var ToastController = /*#__PURE__*/function (_OverlayBaseControlle7) {\n    _inherits(ToastController, _OverlayBaseControlle7);\n\n    var _super12 = _createSuper(ToastController);\n\n    function ToastController() {\n      _classCallCheck(this, ToastController);\n\n      return _super12.call(this, toastController);\n    }\n\n    return _createClass(ToastController);\n  }(OverlayBaseController);\n\n  /** @nocollapse */\n  ToastController.ɵfac = function ToastController_Factory(t) {\n    return new (t || ToastController)();\n  };\n  /** @nocollapse */\n\n\n  ToastController.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ToastController,\n    factory: ToastController.ɵfac,\n    providedIn: 'root'\n  });\n  return ToastController;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar DomController = /*#__PURE__*/(function () {\n  var DomController = /*#__PURE__*/function () {\n    function DomController() {\n      _classCallCheck(this, DomController);\n    }\n\n    _createClass(DomController, [{\n      key: \"read\",\n      value:\n      /**\n       * Schedules a task to run during the READ phase of the next frame.\n       * This task should only read the DOM, but never modify it.\n       */\n      function read(cb) {\n        getQueue().read(cb);\n      }\n      /**\n       * Schedules a task to run during the WRITE phase of the next frame.\n       * This task should write the DOM, but never READ it.\n       */\n\n    }, {\n      key: \"write\",\n      value: function write(cb) {\n        getQueue().write(cb);\n      }\n    }]);\n\n    return DomController;\n  }();\n\n  /** @nocollapse */\n  DomController.ɵfac = function DomController_Factory(t) {\n    return new (t || DomController)();\n  };\n  /** @nocollapse */\n\n\n  DomController.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: DomController,\n    factory: DomController.ɵfac,\n    providedIn: 'root'\n  });\n  return DomController;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar getQueue = function getQueue() {\n  var win = typeof window !== 'undefined' ? window : null;\n\n  if (win != null) {\n    var Ionic = win.Ionic;\n\n    if (Ionic === null || Ionic === void 0 ? void 0 : Ionic.queue) {\n      return Ionic.queue;\n    }\n\n    return {\n      read: function read(cb) {\n        return win.requestAnimationFrame(cb);\n      },\n      write: function write(cb) {\n        return win.requestAnimationFrame(cb);\n      }\n    };\n  }\n\n  return {\n    read: function read(cb) {\n      return cb();\n    },\n    write: function write(cb) {\n      return cb();\n    }\n  };\n};\n\nvar AnimationController = /*#__PURE__*/(function () {\n  var AnimationController = /*#__PURE__*/function () {\n    function AnimationController() {\n      _classCallCheck(this, AnimationController);\n    }\n\n    _createClass(AnimationController, [{\n      key: \"create\",\n      value:\n      /**\n       * Create a new animation\n       */\n      function create(animationId) {\n        return createAnimation(animationId);\n      }\n      /**\n       * EXPERIMENTAL\n       *\n       * Given a progression and a cubic bezier function,\n       * this utility returns the time value(s) at which the\n       * cubic bezier reaches the given time progression.\n       *\n       * If the cubic bezier never reaches the progression\n       * the result will be an empty array.\n       *\n       * This is most useful for switching between easing curves\n       * when doing a gesture animation (i.e. going from linear easing\n       * during a drag, to another easing when `progressEnd` is called)\n       */\n\n    }, {\n      key: \"easingTime\",\n      value: function easingTime(p0, p1, p2, p3, progression) {\n        return getTimeGivenProgression(p0, p1, p2, p3, progression);\n      }\n    }]);\n\n    return AnimationController;\n  }();\n\n  /** @nocollapse */\n  AnimationController.ɵfac = function AnimationController_Factory(t) {\n    return new (t || AnimationController)();\n  };\n  /** @nocollapse */\n\n\n  AnimationController.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AnimationController,\n    factory: AnimationController.ɵfac,\n    providedIn: 'root'\n  });\n  return AnimationController;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar GestureController = /*#__PURE__*/(function () {\n  var GestureController = /*#__PURE__*/function () {\n    function GestureController(zone) {\n      _classCallCheck(this, GestureController);\n\n      this.zone = zone;\n    }\n    /**\n     * Create a new gesture\n     */\n\n\n    _createClass(GestureController, [{\n      key: \"create\",\n      value: function create(opts) {\n        var _this21 = this;\n\n        var runInsideAngularZone = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n        if (runInsideAngularZone) {\n          Object.getOwnPropertyNames(opts).forEach(function (key) {\n            if (typeof opts[key] === 'function') {\n              var fn = opts[key];\n\n              opts[key] = function () {\n                for (var _len = arguments.length, props = new Array(_len), _key = 0; _key < _len; _key++) {\n                  props[_key] = arguments[_key];\n                }\n\n                return _this21.zone.run(function () {\n                  return fn.apply(void 0, props);\n                });\n              };\n            }\n          });\n        }\n\n        return createGesture(opts);\n      }\n    }]);\n\n    return GestureController;\n  }();\n\n  /** @nocollapse */\n  GestureController.ɵfac = function GestureController_Factory(t) {\n    return new (t || GestureController)(i0.ɵɵinject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  GestureController.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: GestureController,\n    factory: GestureController.ɵfac,\n    providedIn: 'root'\n  });\n  return GestureController;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IonicRouteStrategy = /*#__PURE__*/function () {\n  function IonicRouteStrategy() {\n    _classCallCheck(this, IonicRouteStrategy);\n  }\n\n  _createClass(IonicRouteStrategy, [{\n    key: \"shouldDetach\",\n    value: // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    function shouldDetach(_route) {\n      return false;\n    } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  }, {\n    key: \"shouldAttach\",\n    value: function shouldAttach(_route) {\n      return false;\n    }\n  }, {\n    key: \"store\",\n    value: function store( // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _route, // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _detachedTree) {\n      return;\n    } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  }, {\n    key: \"retrieve\",\n    value: function retrieve(_route) {\n      return null;\n    }\n  }, {\n    key: \"shouldReuseRoute\",\n    value: function shouldReuseRoute(future, curr) {\n      if (future.routeConfig !== curr.routeConfig) {\n        return false;\n      } // checking router params\n\n\n      var futureParams = future.params;\n      var currentParams = curr.params;\n      var keysA = Object.keys(futureParams);\n      var keysB = Object.keys(currentParams);\n\n      if (keysA.length !== keysB.length) {\n        return false;\n      } // Test for A's keys different from B.\n\n\n      for (var _i = 0, _keysA = keysA; _i < _keysA.length; _i++) {\n        var key = _keysA[_i];\n\n        if (currentParams[key] !== futureParams[key]) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }]);\n\n  return IonicRouteStrategy;\n}();\n/**\n *  https://ionicframework.com/docs/api/router-outlet#life-cycle-hooks\n */\n\n\nvar appInitialize = function appInitialize(config, doc, zone) {\n  return function () {\n    var win = doc.defaultView;\n\n    if (win && typeof window !== 'undefined') {\n      setupConfig(Object.assign(Object.assign({}, config), {\n        _zoneGate: function _zoneGate(h) {\n          return zone.run(h);\n        }\n      }));\n      var aelFn = '__zone_symbol__addEventListener' in doc.body ? '__zone_symbol__addEventListener' : 'addEventListener';\n      return applyPolyfills().then(function () {\n        return defineCustomElements(win, {\n          exclude: ['ion-tabs', 'ion-tab'],\n          syncQueue: true,\n          raf: raf,\n          jmp: function jmp(h) {\n            return zone.runOutsideAngular(h);\n          },\n          ael: function ael(elm, eventName, cb, opts) {\n            elm[aelFn](eventName, cb, opts);\n          },\n          rel: function rel(elm, eventName, cb, opts) {\n            elm.removeEventListener(eventName, cb, opts);\n          }\n        });\n      });\n    }\n  };\n};\n\nvar DECLARATIONS = [// proxies\nIonAccordion, IonAccordionGroup, IonApp, IonAvatar, IonBackButton, IonBackdrop, IonBadge, IonBreadcrumb, IonBreadcrumbs, IonButton, IonButtons, IonCard, IonCardContent, IonCardHeader, IonCardSubtitle, IonCardTitle, IonCheckbox, IonChip, IonCol, IonContent, IonDatetime, IonFab, IonFabButton, IonFabList, IonFooter, IonGrid, IonHeader, IonIcon, IonImg, IonInfiniteScroll, IonInfiniteScrollContent, IonInput, IonItem, IonItemDivider, IonItemGroup, IonItemOption, IonItemOptions, IonItemSliding, IonLabel, IonList, IonListHeader, IonMenu, IonMenuButton, IonMenuToggle, IonModal, IonNav, IonNavLink, IonNote, IonPopover, IonProgressBar, IonRadio, IonRadioGroup, IonRange, IonRefresher, IonRefresherContent, IonReorder, IonReorderGroup, IonRippleEffect, IonRow, IonSearchbar, IonSegment, IonSegmentButton, IonSelect, IonSelectOption, IonSkeletonText, IonSlide, IonSlides, IonSpinner, IonSplitPane, IonTabBar, IonTabButton, IonText, IonTextarea, IonThumbnail, IonToggle, IonToolbar, IonTitle, IonTabs, // ngModel accessors\nBooleanValueAccessorDirective, NumericValueAccessorDirective, RadioValueAccessorDirective, SelectValueAccessorDirective, TextValueAccessorDirective, // navigation\nIonRouterOutlet, IonBackButtonDelegateDirective, NavDelegate, RouterLinkDelegateDirective, RouterLinkWithHrefDelegateDirective, // virtual scroll\nVirtualFooter, VirtualHeader, VirtualItem, IonVirtualScroll];\nvar IonicModule = /*#__PURE__*/(function () {\n  var IonicModule = /*#__PURE__*/function () {\n    function IonicModule() {\n      _classCallCheck(this, IonicModule);\n    }\n\n    _createClass(IonicModule, null, [{\n      key: \"forRoot\",\n      value: function forRoot(config) {\n        return {\n          ngModule: IonicModule,\n          providers: [{\n            provide: ConfigToken,\n            useValue: config\n          }, {\n            provide: APP_INITIALIZER,\n            useFactory: appInitialize,\n            multi: true,\n            deps: [ConfigToken, DOCUMENT, NgZone]\n          }]\n        };\n      }\n    }]);\n\n    return IonicModule;\n  }();\n\n  /** @nocollapse */\n  IonicModule.ɵfac = function IonicModule_Factory(t) {\n    return new (t || IonicModule)();\n  };\n  /** @nocollapse */\n\n\n  IonicModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IonicModule\n  });\n  /** @nocollapse */\n\n  IonicModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [AngularDelegate, ModalController, PopoverController],\n    imports: [[CommonModule]]\n  });\n  return IonicModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // DIRECTIVES\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { ActionSheetController, AlertController, AngularDelegate, AnimationController, BooleanValueAccessorDirective as BooleanValueAccessor, Config, DomController, GestureController, IonAccordion, IonAccordionGroup, IonApp, IonAvatar, IonBackButton, IonBackButtonDelegateDirective as IonBackButtonDelegate, IonBackdrop, IonBadge, IonBreadcrumb, IonBreadcrumbs, IonButton, IonButtons, IonCard, IonCardContent, IonCardHeader, IonCardSubtitle, IonCardTitle, IonCheckbox, IonChip, IonCol, IonContent, IonDatetime, IonFab, IonFabButton, IonFabList, IonFooter, IonGrid, IonHeader, IonIcon, IonImg, IonInfiniteScroll, IonInfiniteScrollContent, IonInput, IonItem, IonItemDivider, IonItemGroup, IonItemOption, IonItemOptions, IonItemSliding, IonLabel, IonList, IonListHeader, IonMenu, IonMenuButton, IonMenuToggle, IonModal, IonNav, IonNavLink, IonNote, IonPopover, IonProgressBar, IonRadio, IonRadioGroup, IonRange, IonRefresher, IonRefresherContent, IonReorder, IonReorderGroup, IonRippleEffect, IonRouterOutlet, IonRow, IonSearchbar, IonSegment, IonSegmentButton, IonSelect, IonSelectOption, IonSkeletonText, IonSlide, IonSlides, IonSpinner, IonSplitPane, IonTabBar, IonTabButton, IonTabs, IonText, IonTextarea, IonThumbnail, IonTitle, IonToggle, IonToolbar, IonVirtualScroll, IonicModule, IonicRouteStrategy, LoadingController, MenuController, ModalController, NavController, NavDelegate, NavParams, NumericValueAccessorDirective as NumericValueAccessor, PickerController, Platform, PopoverController, RadioValueAccessorDirective as RadioValueAccessor, RouterLinkDelegateDirective as RouterLinkDelegate, RouterLinkWithHrefDelegateDirective as RouterLinkWithHrefDelegate, SelectValueAccessorDirective as SelectValueAccessor, TextValueAccessorDirective as TextValueAccessor, ToastController, VirtualFooter, VirtualHeader, VirtualItem }; //# sourceMappingURL=ionic-angular.js.map","map":null,"metadata":{},"sourceType":"module"}