{"ast":null,"code":"import _defineProperty from \"F:\\\\New folder (17)\\\\nd0067-c4-deployment-process-project-starter\\\\udagram\\\\udagram-frontend\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\defineProperty.js\";\nimport _asyncToGenerator from \"F:\\\\New folder (17)\\\\nd0067-c4-deployment-process-project-starter\\\\udagram\\\\udagram-frontend\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\nimport _classCallCheck from \"F:\\\\New folder (17)\\\\nd0067-c4-deployment-process-project-starter\\\\udagram\\\\udagram-frontend\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\classCallCheck.js\";\nimport _createClass from \"F:\\\\New folder (17)\\\\nd0067-c4-deployment-process-project-starter\\\\udagram\\\\udagram-frontend\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createClass.js\";\n\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, \"throw\" === context.method) { if (delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel; context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, \"constructor\", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { r as registerInstance, e as createEvent, h, H as Host, i as getElement } from './index-b3eecb14.js';\nimport { b as getIonMode } from './ionic-global-f1ce4d2d.js';\nimport { f as focusElement, k as findItemLabel, d as getAriaLabel, e as renderHiddenInput } from './helpers-4d272360.js';\nimport { c as popoverController, b as actionSheetController, a as alertController, s as safeCall } from './overlays-ff47fddd.js';\nimport { h as hostContext, g as getClassMap } from './theme-7670341c.js';\nimport './hardware-back-button-490df115.js';\n\nvar watchForOptions = function watchForOptions(containerEl, tagName, onChange) {\n  if (typeof MutationObserver === 'undefined') {\n    return;\n  }\n\n  var mutation = new MutationObserver(function (mutationList) {\n    onChange(getSelectedOption(mutationList, tagName));\n  });\n  mutation.observe(containerEl, {\n    childList: true,\n    subtree: true\n  });\n  return mutation;\n};\n\nvar getSelectedOption = function getSelectedOption(mutationList, tagName) {\n  var newOption;\n  mutationList.forEach(function (mut) {\n    // eslint-disable-next-line @typescript-eslint/prefer-for-of\n    for (var i = 0; i < mut.addedNodes.length; i++) {\n      newOption = findCheckedOption(mut.addedNodes[i], tagName) || newOption;\n    }\n  });\n  return newOption;\n};\n\nvar findCheckedOption = function findCheckedOption(el, tagName) {\n  if (el.nodeType !== 1) {\n    return undefined;\n  }\n\n  var options = el.tagName === tagName.toUpperCase() ? [el] : Array.from(el.querySelectorAll(tagName));\n  return options.find(function (o) {\n    return o.value === el.value;\n  });\n};\n\nvar selectIosCss = \":host{--placeholder-color:currentColor;--placeholder-opacity:0.33;padding-left:var(--padding-start);padding-right:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);display:-ms-flexbox;display:flex;position:relative;-ms-flex-align:center;align-items:center;font-family:var(--ion-font-family, inherit);overflow:hidden;z-index:2}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){:host{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end)}}:host(.in-item){position:static;max-width:45%}:host(.select-disabled){opacity:0.4;pointer-events:none}:host(.ion-focused) button{border:2px solid #5e9ed6}.select-placeholder{color:var(--placeholder-color);opacity:var(--placeholder-opacity)}label{left:0;top:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;position:absolute;width:100%;height:100%;border:0;background:transparent;cursor:pointer;-webkit-appearance:none;-moz-appearance:none;appearance:none;outline:none;display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;opacity:0}[dir=rtl] label,:host-context([dir=rtl]) label{left:unset;right:unset;right:0}label::-moz-focus-inner{border:0}button{position:absolute;top:0;left:0;right:0;bottom:0;width:100%;height:100%;margin:0;padding:0;border:0;outline:0;clip:rect(0 0 0 0);opacity:0;overflow:hidden;-webkit-appearance:none;-moz-appearance:none}.select-icon{position:relative}.select-text{-ms-flex:1;flex:1;min-width:16px;font-size:inherit;text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.select-icon-inner{left:5px;top:50%;margin-top:-2px;position:absolute;width:0;height:0;border-top:5px solid;border-right:5px solid transparent;border-left:5px solid transparent;color:currentColor;pointer-events:none}[dir=rtl] .select-icon-inner,:host-context([dir=rtl]) .select-icon-inner{left:unset;right:unset;right:5px}:host{--padding-top:10px;--padding-end:10px;--padding-bottom:10px;--padding-start:20px}.select-icon{width:12px;height:18px;opacity:0.33}\";\nvar selectMdCss = \":host{--placeholder-color:currentColor;--placeholder-opacity:0.33;padding-left:var(--padding-start);padding-right:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);display:-ms-flexbox;display:flex;position:relative;-ms-flex-align:center;align-items:center;font-family:var(--ion-font-family, inherit);overflow:hidden;z-index:2}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){:host{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end)}}:host(.in-item){position:static;max-width:45%}:host(.select-disabled){opacity:0.4;pointer-events:none}:host(.ion-focused) button{border:2px solid #5e9ed6}.select-placeholder{color:var(--placeholder-color);opacity:var(--placeholder-opacity)}label{left:0;top:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;position:absolute;width:100%;height:100%;border:0;background:transparent;cursor:pointer;-webkit-appearance:none;-moz-appearance:none;appearance:none;outline:none;display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;opacity:0}[dir=rtl] label,:host-context([dir=rtl]) label{left:unset;right:unset;right:0}label::-moz-focus-inner{border:0}button{position:absolute;top:0;left:0;right:0;bottom:0;width:100%;height:100%;margin:0;padding:0;border:0;outline:0;clip:rect(0 0 0 0);opacity:0;overflow:hidden;-webkit-appearance:none;-moz-appearance:none}.select-icon{position:relative}.select-text{-ms-flex:1;flex:1;min-width:16px;font-size:inherit;text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.select-icon-inner{left:5px;top:50%;margin-top:-2px;position:absolute;width:0;height:0;border-top:5px solid;border-right:5px solid transparent;border-left:5px solid transparent;color:currentColor;pointer-events:none}[dir=rtl] .select-icon-inner,:host-context([dir=rtl]) .select-icon-inner{left:unset;right:unset;right:5px}:host{--padding-top:10px;--padding-end:0;--padding-bottom:10px;--padding-start:16px}.select-icon{width:19px;height:19px;-webkit-transition:-webkit-transform 0.15s cubic-bezier(0.4, 0, 0.2, 1);transition:-webkit-transform 0.15s cubic-bezier(0.4, 0, 0.2, 1);transition:transform 0.15s cubic-bezier(0.4, 0, 0.2, 1);transition:transform 0.15s cubic-bezier(0.4, 0, 0.2, 1), -webkit-transform 0.15s cubic-bezier(0.4, 0, 0.2, 1);opacity:0.55}:host-context(.item-label-stacked) .select-icon,:host-context(.item-label-floating:not(.item-fill-outline)) .select-icon,:host-context(.item-label-floating.item-fill-outline){-webkit-transform:translate3d(0,  -9px,  0);transform:translate3d(0,  -9px,  0)}:host-context(.item-has-focus) .select-icon{-webkit-transform:rotate(180deg);transform:rotate(180deg)}:host-context(.item-has-focus.item-label-stacked) .select-icon,:host-context(.item-has-focus.item-label-floating:not(.item-fill-outline)) .select-icon{-webkit-transform:translate3d(0,  -9px,  0) rotate(180deg);transform:translate3d(0,  -9px,  0) rotate(180deg)}:host-context(ion-item.ion-focused) .select-icon,:host-context(.item-has-focus) .select-icon{color:var(--highlight-color-focused);opacity:1}\";\n\nvar Select = /*#__PURE__*/function () {\n  function Select(hostRef) {\n    var _this = this;\n\n    _classCallCheck(this, Select);\n\n    registerInstance(this, hostRef);\n    this.ionChange = createEvent(this, \"ionChange\", 7);\n    this.ionCancel = createEvent(this, \"ionCancel\", 7);\n    this.ionDismiss = createEvent(this, \"ionDismiss\", 7);\n    this.ionFocus = createEvent(this, \"ionFocus\", 7);\n    this.ionBlur = createEvent(this, \"ionBlur\", 7);\n    this.ionStyle = createEvent(this, \"ionStyle\", 7);\n    this.inputId = \"ion-sel-\".concat(selectIds++);\n    this.didInit = false;\n    this.isExpanded = false;\n    /**\n     * If `true`, the user cannot interact with the select.\n     */\n\n    this.disabled = false;\n    /**\n     * The text to display on the cancel button.\n     */\n\n    this.cancelText = 'Cancel';\n    /**\n     * The text to display on the ok button.\n     */\n\n    this.okText = 'OK';\n    /**\n     * The name of the control, which is submitted with the form data.\n     */\n\n    this.name = this.inputId;\n    /**\n     * If `true`, the select can accept multiple values.\n     */\n\n    this.multiple = false;\n    /**\n     * The interface the select should use: `action-sheet`, `popover` or `alert`.\n     */\n\n    this.interface = 'alert';\n    /**\n     * Any additional options that the `alert`, `action-sheet` or `popover` interface\n     * can take. See the [ion-alert docs](./alert), the\n     * [ion-action-sheet docs](./action-sheet) and the\n     * [ion-popover docs](./popover) for the\n     * create options for each interface.\n     *\n     * Note: `interfaceOptions` will not override `inputs` or `buttons` with the `alert` interface.\n     */\n\n    this.interfaceOptions = {};\n\n    this.onClick = function (ev) {\n      _this.setFocus();\n\n      _this.open(ev);\n    };\n\n    this.onFocus = function () {\n      _this.ionFocus.emit();\n    };\n\n    this.onBlur = function () {\n      _this.ionBlur.emit();\n    };\n  }\n\n  _createClass(Select, [{\n    key: \"styleChanged\",\n    value: function styleChanged() {\n      this.emitStyle();\n    }\n  }, {\n    key: \"valueChanged\",\n    value: function valueChanged() {\n      this.emitStyle();\n\n      if (this.didInit) {\n        this.ionChange.emit({\n          value: this.value\n        });\n      }\n    }\n  }, {\n    key: \"connectedCallback\",\n    value: function () {\n      var _connectedCallback = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var _this2 = this;\n\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                this.updateOverlayOptions();\n                this.emitStyle();\n                this.mutationO = watchForOptions(this.el, 'ion-select-option', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n                  return _regeneratorRuntime().wrap(function _callee$(_context) {\n                    while (1) {\n                      switch (_context.prev = _context.next) {\n                        case 0:\n                          _this2.updateOverlayOptions();\n\n                        case 1:\n                        case \"end\":\n                          return _context.stop();\n                      }\n                    }\n                  }, _callee);\n                })));\n\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function connectedCallback() {\n        return _connectedCallback.apply(this, arguments);\n      }\n\n      return connectedCallback;\n    }()\n  }, {\n    key: \"disconnectedCallback\",\n    value: function disconnectedCallback() {\n      if (this.mutationO) {\n        this.mutationO.disconnect();\n        this.mutationO = undefined;\n      }\n    }\n  }, {\n    key: \"componentDidLoad\",\n    value: function componentDidLoad() {\n      this.didInit = true;\n    }\n    /**\n     * Open the select overlay. The overlay is either an alert, action sheet, or popover,\n     * depending on the `interface` property on the `ion-select`.\n     *\n     * @param event The user interface event that called the open.\n     */\n\n  }, {\n    key: \"open\",\n    value: function () {\n      var _open = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(event) {\n        var _this3 = this;\n\n        var overlay, indexOfSelected, selectedEl;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!(this.disabled || this.isExpanded)) {\n                  _context3.next = 2;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", undefined);\n\n              case 2:\n                this.isExpanded = true;\n                _context3.next = 5;\n                return this.createOverlay(event);\n\n              case 5:\n                overlay = this.overlay = _context3.sent;\n                overlay.onDidDismiss().then(function () {\n                  _this3.overlay = undefined;\n                  _this3.isExpanded = false;\n\n                  _this3.ionDismiss.emit();\n\n                  _this3.setFocus();\n                });\n                _context3.next = 9;\n                return overlay.present();\n\n              case 9:\n                // focus selected option for popovers\n                if (this.interface === 'popover') {\n                  indexOfSelected = this.childOpts.map(function (o) {\n                    return o.value;\n                  }).indexOf(this.value);\n                  indexOfSelected = indexOfSelected > -1 ? indexOfSelected : 0; // default to first option if nothing selected\n\n                  selectedEl = overlay.querySelector(\".select-interface-option:nth-child(\".concat(indexOfSelected + 1, \")\"));\n\n                  if (selectedEl) {\n                    focusElement(selectedEl);\n                  }\n                }\n\n                return _context3.abrupt(\"return\", overlay);\n\n              case 11:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function open(_x) {\n        return _open.apply(this, arguments);\n      }\n\n      return open;\n    }()\n  }, {\n    key: \"createOverlay\",\n    value: function createOverlay(ev) {\n      var selectInterface = this.interface;\n\n      if (selectInterface === 'action-sheet' && this.multiple) {\n        console.warn(\"Select interface cannot be \\\"\".concat(selectInterface, \"\\\" with a multi-value select. Using the \\\"alert\\\" interface instead.\"));\n        selectInterface = 'alert';\n      }\n\n      if (selectInterface === 'popover' && !ev) {\n        console.warn(\"Select interface cannot be a \\\"\".concat(selectInterface, \"\\\" without passing an event. Using the \\\"alert\\\" interface instead.\"));\n        selectInterface = 'alert';\n      }\n\n      if (selectInterface === 'action-sheet') {\n        return this.openActionSheet();\n      }\n\n      if (selectInterface === 'popover') {\n        return this.openPopover(ev);\n      }\n\n      return this.openAlert();\n    }\n  }, {\n    key: \"updateOverlayOptions\",\n    value: function updateOverlayOptions() {\n      var overlay = this.overlay;\n\n      if (!overlay) {\n        return;\n      }\n\n      var childOpts = this.childOpts;\n      var value = this.value;\n\n      switch (this.interface) {\n        case 'action-sheet':\n          overlay.buttons = this.createActionSheetButtons(childOpts, value);\n          break;\n\n        case 'popover':\n          var popover = overlay.querySelector('ion-select-popover');\n\n          if (popover) {\n            popover.options = this.createPopoverOptions(childOpts, value);\n          }\n\n          break;\n\n        case 'alert':\n          var inputType = this.multiple ? 'checkbox' : 'radio';\n          overlay.inputs = this.createAlertInputs(childOpts, inputType, value);\n          break;\n      }\n    }\n  }, {\n    key: \"createActionSheetButtons\",\n    value: function createActionSheetButtons(data, selectValue) {\n      var _this4 = this;\n\n      var actionSheetButtons = data.map(function (option) {\n        var value = getOptionValue(option); // Remove hydrated before copying over classes\n\n        var copyClasses = Array.from(option.classList).filter(function (cls) {\n          return cls !== 'hydrated';\n        }).join(' ');\n        var optClass = \"\".concat(OPTION_CLASS, \" \").concat(copyClasses);\n        return {\n          role: isOptionSelected(selectValue, value, _this4.compareWith) ? 'selected' : '',\n          text: option.textContent,\n          cssClass: optClass,\n          handler: function handler() {\n            _this4.value = value;\n          }\n        };\n      }); // Add \"cancel\" button\n\n      actionSheetButtons.push({\n        text: this.cancelText,\n        role: 'cancel',\n        handler: function handler() {\n          _this4.ionCancel.emit();\n        }\n      });\n      return actionSheetButtons;\n    }\n  }, {\n    key: \"createAlertInputs\",\n    value: function createAlertInputs(data, inputType, selectValue) {\n      var _this5 = this;\n\n      var alertInputs = data.map(function (option) {\n        var value = getOptionValue(option); // Remove hydrated before copying over classes\n\n        var copyClasses = Array.from(option.classList).filter(function (cls) {\n          return cls !== 'hydrated';\n        }).join(' ');\n        var optClass = \"\".concat(OPTION_CLASS, \" \").concat(copyClasses);\n        return {\n          type: inputType,\n          cssClass: optClass,\n          label: option.textContent || '',\n          value: value,\n          checked: isOptionSelected(selectValue, value, _this5.compareWith),\n          disabled: option.disabled\n        };\n      });\n      return alertInputs;\n    }\n  }, {\n    key: \"createPopoverOptions\",\n    value: function createPopoverOptions(data, selectValue) {\n      var _this6 = this;\n\n      var popoverOptions = data.map(function (option) {\n        var value = getOptionValue(option); // Remove hydrated before copying over classes\n\n        var copyClasses = Array.from(option.classList).filter(function (cls) {\n          return cls !== 'hydrated';\n        }).join(' ');\n        var optClass = \"\".concat(OPTION_CLASS, \" \").concat(copyClasses);\n        return {\n          text: option.textContent || '',\n          cssClass: optClass,\n          value: value,\n          checked: isOptionSelected(selectValue, value, _this6.compareWith),\n          disabled: option.disabled,\n          handler: function handler(selected) {\n            _this6.value = selected;\n\n            if (!_this6.multiple) {\n              _this6.close();\n            }\n          }\n        };\n      });\n      return popoverOptions;\n    }\n  }, {\n    key: \"openPopover\",\n    value: function () {\n      var _openPopover = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(ev) {\n        var interfaceOptions, mode, showBackdrop, multiple, value, event, size, item, popoverOpts;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                interfaceOptions = this.interfaceOptions;\n                mode = getIonMode(this);\n                showBackdrop = mode === 'md' ? false : true;\n                multiple = this.multiple;\n                value = this.value;\n                event = ev;\n                size = 'auto';\n                item = this.el.closest('ion-item'); // If the select is inside of an item containing a floating\n                // or stacked label then the popover should take up the\n                // full width of the item when it presents\n\n                if (item && (item.classList.contains('item-label-floating') || item.classList.contains('item-label-stacked'))) {\n                  event = Object.assign(Object.assign({}, ev), {\n                    detail: {\n                      ionShadowTarget: item\n                    }\n                  });\n                  size = 'cover';\n                }\n\n                popoverOpts = Object.assign(Object.assign({\n                  mode: mode,\n                  event: event,\n                  alignment: 'center',\n                  size: size,\n                  showBackdrop: showBackdrop\n                }, interfaceOptions), {\n                  component: 'ion-select-popover',\n                  cssClass: ['select-popover', interfaceOptions.cssClass],\n                  componentProps: {\n                    header: interfaceOptions.header,\n                    subHeader: interfaceOptions.subHeader,\n                    message: interfaceOptions.message,\n                    multiple: multiple,\n                    value: value,\n                    options: this.createPopoverOptions(this.childOpts, value)\n                  }\n                });\n                return _context4.abrupt(\"return\", popoverController.create(popoverOpts));\n\n              case 11:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function openPopover(_x2) {\n        return _openPopover.apply(this, arguments);\n      }\n\n      return openPopover;\n    }()\n  }, {\n    key: \"openActionSheet\",\n    value: function () {\n      var _openActionSheet = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var mode, interfaceOptions, actionSheetOpts;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                mode = getIonMode(this);\n                interfaceOptions = this.interfaceOptions;\n                actionSheetOpts = Object.assign(Object.assign({\n                  mode: mode\n                }, interfaceOptions), {\n                  buttons: this.createActionSheetButtons(this.childOpts, this.value),\n                  cssClass: ['select-action-sheet', interfaceOptions.cssClass]\n                });\n                return _context5.abrupt(\"return\", actionSheetController.create(actionSheetOpts));\n\n              case 4:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function openActionSheet() {\n        return _openActionSheet.apply(this, arguments);\n      }\n\n      return openActionSheet;\n    }()\n  }, {\n    key: \"openAlert\",\n    value: function () {\n      var _openAlert = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n        var _this7 = this;\n\n        var label, labelText, interfaceOptions, inputType, mode, alertOpts;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                label = this.getLabel();\n                labelText = label ? label.textContent : null;\n                interfaceOptions = this.interfaceOptions;\n                inputType = this.multiple ? 'checkbox' : 'radio';\n                mode = getIonMode(this);\n                alertOpts = Object.assign(Object.assign({\n                  mode: mode\n                }, interfaceOptions), {\n                  header: interfaceOptions.header ? interfaceOptions.header : labelText,\n                  inputs: this.createAlertInputs(this.childOpts, inputType, this.value),\n                  buttons: [{\n                    text: this.cancelText,\n                    role: 'cancel',\n                    handler: function handler() {\n                      _this7.ionCancel.emit();\n                    }\n                  }, {\n                    text: this.okText,\n                    handler: function handler(selectedValues) {\n                      _this7.value = selectedValues;\n                    }\n                  }],\n                  cssClass: ['select-alert', interfaceOptions.cssClass, this.multiple ? 'multiple-select-alert' : 'single-select-alert']\n                });\n                return _context6.abrupt(\"return\", alertController.create(alertOpts));\n\n              case 7:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function openAlert() {\n        return _openAlert.apply(this, arguments);\n      }\n\n      return openAlert;\n    }()\n    /**\n     * Close the select interface.\n     */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      // TODO check !this.overlay || !this.isFocus()\n      if (!this.overlay) {\n        return Promise.resolve(false);\n      }\n\n      return this.overlay.dismiss();\n    }\n  }, {\n    key: \"getLabel\",\n    value: function getLabel() {\n      return findItemLabel(this.el);\n    }\n  }, {\n    key: \"hasValue\",\n    value: function hasValue() {\n      return this.getText() !== '';\n    }\n  }, {\n    key: \"childOpts\",\n    get: function get() {\n      return Array.from(this.el.querySelectorAll('ion-select-option'));\n    }\n  }, {\n    key: \"getText\",\n    value: function getText() {\n      var selectedText = this.selectedText;\n\n      if (selectedText != null && selectedText !== '') {\n        return selectedText;\n      }\n\n      return generateText(this.childOpts, this.value, this.compareWith);\n    }\n  }, {\n    key: \"setFocus\",\n    value: function setFocus() {\n      if (this.focusEl) {\n        this.focusEl.focus();\n      }\n    }\n  }, {\n    key: \"emitStyle\",\n    value: function emitStyle() {\n      this.ionStyle.emit({\n        interactive: true,\n        'interactive-disabled': this.disabled,\n        select: true,\n        'select-disabled': this.disabled,\n        'has-placeholder': this.placeholder !== undefined,\n        'has-value': this.hasValue(),\n        'has-focus': this.isExpanded\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _class,\n          _this8 = this;\n\n      var disabled = this.disabled,\n          el = this.el,\n          inputId = this.inputId,\n          isExpanded = this.isExpanded,\n          name = this.name,\n          placeholder = this.placeholder,\n          value = this.value;\n      var mode = getIonMode(this);\n\n      var _getAriaLabel = getAriaLabel(el, inputId),\n          labelText = _getAriaLabel.labelText,\n          labelId = _getAriaLabel.labelId;\n\n      renderHiddenInput(true, el, name, parseValue(value), disabled);\n      var displayValue = this.getText();\n      var addPlaceholderClass = false;\n      var selectText = displayValue;\n\n      if (selectText === '' && placeholder !== undefined) {\n        selectText = placeholder;\n        addPlaceholderClass = true;\n      }\n\n      var selectTextClasses = {\n        'select-text': true,\n        'select-placeholder': addPlaceholderClass\n      };\n      var textPart = addPlaceholderClass ? 'placeholder' : 'text'; // If there is a label then we need to concatenate it with the\n      // current value (or placeholder) and a comma so it separates\n      // nicely when the screen reader announces it, otherwise just\n      // announce the value / placeholder\n\n      var displayLabel = labelText !== undefined ? selectText !== '' ? \"\".concat(selectText, \", \").concat(labelText) : labelText : selectText;\n      return h(Host, {\n        onClick: this.onClick,\n        role: \"button\",\n        \"aria-haspopup\": \"listbox\",\n        \"aria-disabled\": disabled ? 'true' : null,\n        \"aria-label\": displayLabel,\n        class: (_class = {}, _defineProperty(_class, mode, true), _defineProperty(_class, 'in-item', hostContext('ion-item', el)), _defineProperty(_class, 'select-disabled', disabled), _defineProperty(_class, 'select-expanded', isExpanded), _class)\n      }, h(\"div\", {\n        \"aria-hidden\": \"true\",\n        class: selectTextClasses,\n        part: textPart\n      }, selectText), h(\"div\", {\n        class: \"select-icon\",\n        role: \"presentation\",\n        part: \"icon\"\n      }, h(\"div\", {\n        class: \"select-icon-inner\"\n      })), h(\"label\", {\n        id: labelId\n      }, displayLabel), h(\"button\", {\n        type: \"button\",\n        disabled: disabled,\n        id: inputId,\n        \"aria-labelledby\": labelId,\n        \"aria-haspopup\": \"listbox\",\n        \"aria-expanded\": \"\".concat(isExpanded),\n        onFocus: this.onFocus,\n        onBlur: this.onBlur,\n        ref: function ref(focusEl) {\n          return _this8.focusEl = focusEl;\n        }\n      }));\n    }\n  }, {\n    key: \"el\",\n    get: function get() {\n      return getElement(this);\n    }\n  }], [{\n    key: \"watchers\",\n    get: function get() {\n      return {\n        \"disabled\": [\"styleChanged\"],\n        \"placeholder\": [\"styleChanged\"],\n        \"isExpanded\": [\"styleChanged\"],\n        \"value\": [\"valueChanged\"]\n      };\n    }\n  }]);\n\n  return Select;\n}();\n\nvar isOptionSelected = function isOptionSelected(currentValue, compareValue, compareWith) {\n  if (currentValue === undefined) {\n    return false;\n  }\n\n  if (Array.isArray(currentValue)) {\n    return currentValue.some(function (val) {\n      return compareOptions(val, compareValue, compareWith);\n    });\n  } else {\n    return compareOptions(currentValue, compareValue, compareWith);\n  }\n};\n\nvar getOptionValue = function getOptionValue(el) {\n  var value = el.value;\n  return value === undefined ? el.textContent || '' : value;\n};\n\nvar parseValue = function parseValue(value) {\n  if (value == null) {\n    return undefined;\n  }\n\n  if (Array.isArray(value)) {\n    return value.join(',');\n  }\n\n  return value.toString();\n};\n\nvar compareOptions = function compareOptions(currentValue, compareValue, compareWith) {\n  if (typeof compareWith === 'function') {\n    return compareWith(currentValue, compareValue);\n  } else if (typeof compareWith === 'string') {\n    return currentValue[compareWith] === compareValue[compareWith];\n  } else {\n    return Array.isArray(compareValue) ? compareValue.includes(currentValue) : currentValue === compareValue;\n  }\n};\n\nvar generateText = function generateText(opts, value, compareWith) {\n  if (value === undefined) {\n    return '';\n  }\n\n  if (Array.isArray(value)) {\n    return value.map(function (v) {\n      return textForValue(opts, v, compareWith);\n    }).filter(function (opt) {\n      return opt !== null;\n    }).join(', ');\n  } else {\n    return textForValue(opts, value, compareWith) || '';\n  }\n};\n\nvar textForValue = function textForValue(opts, value, compareWith) {\n  var selectOpt = opts.find(function (opt) {\n    return compareOptions(getOptionValue(opt), value, compareWith);\n  });\n  return selectOpt ? selectOpt.textContent : null;\n};\n\nvar selectIds = 0;\nvar OPTION_CLASS = 'select-interface-option';\nSelect.style = {\n  ios: selectIosCss,\n  md: selectMdCss\n};\nvar selectOptionCss = \":host{display:none}\";\n\nvar SelectOption = /*#__PURE__*/function () {\n  function SelectOption(hostRef) {\n    _classCallCheck(this, SelectOption);\n\n    registerInstance(this, hostRef);\n    this.inputId = \"ion-selopt-\".concat(selectOptionIds++);\n    /**\n     * If `true`, the user cannot interact with the select option. This property does not apply when `interface=\"action-sheet\"` as `ion-action-sheet` does not allow for disabled buttons.\n     */\n\n    this.disabled = false;\n  }\n\n  _createClass(SelectOption, [{\n    key: \"render\",\n    value: function render() {\n      return h(Host, {\n        role: \"option\",\n        id: this.inputId,\n        class: getIonMode(this)\n      });\n    }\n  }, {\n    key: \"el\",\n    get: function get() {\n      return getElement(this);\n    }\n  }]);\n\n  return SelectOption;\n}();\n\nvar selectOptionIds = 0;\nSelectOption.style = selectOptionCss;\nvar selectPopoverIosCss = \".sc-ion-select-popover-ios-h ion-list.sc-ion-select-popover-ios{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0}ion-list-header.sc-ion-select-popover-ios,ion-label.sc-ion-select-popover-ios{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0}\";\nvar selectPopoverMdCss = \".sc-ion-select-popover-md-h ion-list.sc-ion-select-popover-md{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0}ion-list-header.sc-ion-select-popover-md,ion-label.sc-ion-select-popover-md{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0}ion-list.sc-ion-select-popover-md ion-radio.sc-ion-select-popover-md{opacity:0}ion-item.sc-ion-select-popover-md{--inner-border-width:0}.item-radio-checked.sc-ion-select-popover-md{--background:rgba(var(--ion-color-primary-rgb, 56, 128, 255), 0.08);--background-focused:var(--ion-color-primary, #3880ff);--background-focused-opacity:0.2;--background-hover:var(--ion-color-primary, #3880ff);--background-hover-opacity:0.12}.item-checkbox-checked.sc-ion-select-popover-md{--background-activated:var(--ion-item-color, var(--ion-text-color, #000));--background-focused:var(--ion-item-color, var(--ion-text-color, #000));--background-hover:var(--ion-item-color, var(--ion-text-color, #000));--color:var(--ion-color-primary, #3880ff)}\";\n\nvar SelectPopover = /*#__PURE__*/function () {\n  function SelectPopover(hostRef) {\n    _classCallCheck(this, SelectPopover);\n\n    registerInstance(this, hostRef);\n    /**\n     * An array of options for the popover\n     */\n\n    this.options = [];\n  }\n\n  _createClass(SelectPopover, [{\n    key: \"onSelect\",\n    value: function onSelect(ev) {\n      this.setChecked(ev);\n      this.callOptionHandler(ev);\n    }\n  }, {\n    key: \"findOptionFromEvent\",\n    value: function findOptionFromEvent(ev) {\n      var options = this.options;\n      return options.find(function (o) {\n        return o.value === ev.target.value;\n      });\n    }\n    /**\n     * When an option is selected we need to get the value(s)\n     * of the selected option(s) and return it in the option\n     * handler\n     */\n\n  }, {\n    key: \"callOptionHandler\",\n    value: function callOptionHandler(ev) {\n      var option = this.findOptionFromEvent(ev);\n      var values = this.getValues(ev);\n\n      if (option === null || option === void 0 ? void 0 : option.handler) {\n        safeCall(option.handler, values);\n      }\n    }\n    /**\n     * This is required when selecting a radio that is already\n     * selected because it will not trigger the ionChange event\n     * but we still want to close the popover\n     */\n\n  }, {\n    key: \"rbClick\",\n    value: function rbClick(ev) {\n      this.callOptionHandler(ev);\n    }\n  }, {\n    key: \"setChecked\",\n    value: function setChecked(ev) {\n      var multiple = this.multiple;\n      var option = this.findOptionFromEvent(ev); // this is a popover with checkboxes (multiple value select)\n      // we need to set the checked value for this option\n\n      if (multiple && option) {\n        option.checked = ev.detail.checked;\n      }\n    }\n  }, {\n    key: \"getValues\",\n    value: function getValues(ev) {\n      var multiple = this.multiple,\n          options = this.options;\n\n      if (multiple) {\n        // this is a popover with checkboxes (multiple value select)\n        // return an array of all the checked values\n        return options.filter(function (o) {\n          return o.checked;\n        }).map(function (o) {\n          return o.value;\n        });\n      } // this is a popover with radio buttons (single value select)\n      // return the value that was clicked, otherwise undefined\n\n\n      var option = this.findOptionFromEvent(ev);\n      return option ? option.value : undefined;\n    }\n  }, {\n    key: \"renderOptions\",\n    value: function renderOptions(options) {\n      var multiple = this.multiple;\n\n      switch (multiple) {\n        case true:\n          return this.renderCheckboxOptions(options);\n\n        default:\n          return this.renderRadioOptions(options);\n      }\n    }\n  }, {\n    key: \"renderCheckboxOptions\",\n    value: function renderCheckboxOptions(options) {\n      return options.map(function (option) {\n        return h(\"ion-item\", {\n          class: getClassMap(option.cssClass)\n        }, h(\"ion-checkbox\", {\n          slot: \"start\",\n          value: option.value,\n          disabled: option.disabled,\n          checked: option.checked\n        }), h(\"ion-label\", null, option.text));\n      });\n    }\n  }, {\n    key: \"renderRadioOptions\",\n    value: function renderRadioOptions(options) {\n      var _this9 = this;\n\n      var checked = options.filter(function (o) {\n        return o.checked;\n      }).map(function (o) {\n        return o.value;\n      })[0];\n      return h(\"ion-radio-group\", {\n        value: checked\n      }, options.map(function (option) {\n        return h(\"ion-item\", {\n          class: getClassMap(option.cssClass)\n        }, h(\"ion-label\", null, option.text), h(\"ion-radio\", {\n          value: option.value,\n          disabled: option.disabled,\n          onClick: function onClick(ev) {\n            return _this9.rbClick(ev);\n          }\n        }));\n      }));\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var header = this.header,\n          message = this.message,\n          options = this.options,\n          subHeader = this.subHeader;\n      var hasSubHeaderOrMessage = subHeader !== undefined || message !== undefined;\n      return h(Host, {\n        class: getIonMode(this)\n      }, h(\"ion-list\", null, header !== undefined && h(\"ion-list-header\", null, header), hasSubHeaderOrMessage && h(\"ion-item\", null, h(\"ion-label\", {\n        class: \"ion-text-wrap\"\n      }, subHeader !== undefined && h(\"h3\", null, subHeader), message !== undefined && h(\"p\", null, message))), this.renderOptions(options)));\n    }\n  }]);\n\n  return SelectPopover;\n}();\n\nSelectPopover.style = {\n  ios: selectPopoverIosCss,\n  md: selectPopoverMdCss\n};\nexport { Select as ion_select, SelectOption as ion_select_option, SelectPopover as ion_select_popover };","map":null,"metadata":{},"sourceType":"module"}